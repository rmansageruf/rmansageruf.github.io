"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TableFigure = exports.Table = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _reactBeautifulDnd = require("react-beautiful-dnd");
var _hooks = require("../../hooks");
var _utils = require("../../utils");
var _Actions = require("./Actions");
var _Body = require("./Body");
var _Head = require("./Head");
var _HeaderCell = require("./HeaderCell");
var _HeaderCell2 = require("./HeaderCell/HeaderCell");
var _Row = require("./Row");
var _styled = require("./styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const defaultLocalization = {
  ascendingOrder: 'Ascending order',
  descendingOrder: 'Descending order'
};
const InternalTable = props => {
  const {
    actions,
    className,
    columns,
    emptyComponent,
    headerless = false,
    id,
    itemName,
    items,
    keyField = 'id',
    localization = defaultLocalization,
    onRowDrop,
    pagination,
    selectable,
    sortable,
    stickyHeader,
    style,
    ...rest
  } = props;
  const actionsRef = (0, _react.useRef)(null);
  const uniqueTableId = (0, _react.useId)();
  const tableIdRef = (0, _react.useRef)(id || uniqueTableId);
  const isSelectable = Boolean(selectable);
  const [selectedItems, setSelectedItems] = (0, _react.useState)(new Set());
  const [headerCellWidths, setHeaderCellWidths] = (0, _react.useState)([]);
  const headerCellIconRef = (0, _react.useRef)(null);
  const eventCallback = (0, _hooks.useEventCallback)(item => {
    if (!selectable || !item) {
      return;
    }
    const {
      onSelectionChange
    } = selectable;
    const nextIsSelected = !selectedItems.has(item);
    if (nextIsSelected) {
      onSelectionChange([...selectedItems, item]);
    } else {
      onSelectionChange([...selectedItems].filter(selectedItem => selectedItem !== item));
    }
  });
  const selectableConditionalDep = selectable ? selectable.selectedItems : null;
  (0, _react.useEffect)(() => {
    if (selectable) {
      setSelectedItems(new Set(selectable.selectedItems));
    }
  }, [selectable, selectableConditionalDep]);
  const onItemSelect = selectable ? eventCallback : undefined;
  const onSortClick = (0, _react.useCallback)(column => {
    if (!sortable || !column.isSortable) {
      return;
    }
    const {
      hash
    } = column;
    const sortDirection = sortable.direction === 'ASC' ? 'DESC' : 'ASC';
    if (typeof sortable.onSort === 'function') {
      sortable.onSort(hash, sortDirection, column);
    }
  }, [sortable]);
  const onDragEnd = (0, _react.useCallback)(result => {
    const {
      destination,
      source
    } = result;
    if (!destination) {
      return;
    }
    if (destination.droppableId === source.droppableId && destination.index === source.index) {
      return;
    }
    if (typeof onRowDrop === 'function') {
      onRowDrop(source.index, destination.index);
    }
    setHeaderCellWidths([]);
  }, [onRowDrop]);
  const onBeforeDragStart = () => {
    const headerCellIconWidth = headerCellIconRef.current?.offsetWidth ?? 'auto';
    const headerCellsWidths = columns.map((_column, index) => {
      const headerCellElement = window.document.getElementById(`header-cell-${index}`);
      return headerCellElement?.getBoundingClientRect().width ?? 'auto';
    });
    const allHeaderWidths = [headerCellIconWidth, ...headerCellsWidths];
    setHeaderCellWidths(allHeaderWidths);
  };
  const shouldRenderActions = () => {
    return Boolean(actions) || Boolean(pagination) || Boolean(selectable) || Boolean(itemName);
  };
  const getItemKey = (item, index) => {
    if (item[keyField] !== undefined) {
      return item[keyField];
    }
    return index;
  };
  const renderHeaders = () => /*#__PURE__*/_react.default.createElement(_Head.Head, {
    hidden: headerless
  }, /*#__PURE__*/_react.default.createElement("tr", null, typeof onRowDrop === 'function' && /*#__PURE__*/_react.default.createElement(_HeaderCell2.DragIconHeaderCell, {
    actionsRef: actionsRef,
    headerCellIconRef: headerCellIconRef
  }), isSelectable && /*#__PURE__*/_react.default.createElement(_HeaderCell2.HeaderCheckboxCell, {
    actionsRef: actionsRef,
    stickyHeader: stickyHeader
  }), columns.map((column, index) => {
    const {
      display,
      hash,
      header,
      isSortable,
      hideHeader,
      width
    } = column;
    const isSorted = isSortable && sortable && hash === sortable.columnHash;
    const sortDirection = sortable && sortable.direction;
    const headerCellWidth = headerCellWidths[index + 1];
    const widthColumn = headerCellWidth ?? width;
    return /*#__PURE__*/_react.default.createElement(_HeaderCell.HeaderCell, {
      actionsRef: actionsRef,
      column: {
        ...column,
        width: widthColumn
      },
      display: display,
      hide: hideHeader,
      id: `header-cell-${index}`,
      isSorted: isSorted,
      key: index,
      localization: localization,
      onSortClick: onSortClick,
      sortDirection: sortDirection,
      stickyHeader: stickyHeader
    }, header);
  })));
  const renderDroppableItems = () => /*#__PURE__*/_react.default.createElement(_reactBeautifulDnd.Droppable, {
    droppableId: `${uniqueTableId}-bd-droppable`
  }, provided => /*#__PURE__*/_react.default.createElement(_Body.Body, (0, _extends2.default)({
    ref: provided.innerRef,
    withFirstRowBorder: headerless
  }, provided.droppableProps), items.map((item, index) => {
    const key = getItemKey(item, index);
    const isSelected = selectedItems.has(item);
    return /*#__PURE__*/_react.default.createElement(_reactBeautifulDnd.Draggable, {
      draggableId: String(key),
      index: index,
      key: key
    }, (provided, snapshot) => /*#__PURE__*/_react.default.createElement(_Row.Row, (0, _extends2.default)({
      isDragging: snapshot.isDragging
    }, provided.dragHandleProps, provided.draggableProps, {
      columns: columns,
      headerCellWidths: headerCellWidths,
      isSelectable: isSelectable,
      isSelected: isSelected,
      item: item,
      onItemSelect: onItemSelect,
      ref: provided.innerRef,
      showDragIcon: true
    })));
  }), provided.placeholder));
  const renderItems = () => onRowDrop ? renderDroppableItems() : /*#__PURE__*/_react.default.createElement(_Body.Body, {
    withFirstRowBorder: headerless
  }, items.map((item, index) => {
    const key = getItemKey(item, index);
    const isSelected = selectedItems.has(item);
    return /*#__PURE__*/_react.default.createElement(_Row.Row, {
      columns: columns,
      headerCellWidths: headerCellWidths,
      isSelectable: isSelectable,
      isSelected: isSelected,
      item: item,
      key: key,
      onItemSelect: onItemSelect
    });
  }));
  const renderEmptyState = () => {
    if (items.length === 0 && emptyComponent) {
      return emptyComponent;
    }
    return null;
  };
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, shouldRenderActions() && /*#__PURE__*/_react.default.createElement(_Actions.Actions, {
    customActions: actions,
    forwardedRef: actionsRef,
    itemName: itemName,
    items: items,
    onSelectionChange: selectable && selectable.onSelectionChange,
    pagination: pagination,
    selectedItems: selectedItems,
    stickyHeader: stickyHeader,
    tableId: tableIdRef.current
  }), /*#__PURE__*/_react.default.createElement(_styled.StyledTable, (0, _extends2.default)({}, rest, {
    id: tableIdRef.current
  }), onRowDrop ? /*#__PURE__*/_react.default.createElement(_reactBeautifulDnd.DragDropContext, {
    onBeforeDragStart: onBeforeDragStart,
    onDragEnd: onDragEnd
  }, renderHeaders(), renderItems()) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, renderHeaders(), renderItems())), renderEmptyState());
};
const Table = (0, _utils.typedMemo)(InternalTable);
exports.Table = Table;
const TableFigure = /*#__PURE__*/(0, _react.memo)(props => /*#__PURE__*/_react.default.createElement(_styled.StyledTableFigure, props));
exports.TableFigure = TableFigure;