"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatefulTable = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _hooks = require("../../hooks");
var _utils = require("../../utils");
var _Box = require("../Box");
var _PillTabs = require("../PillTabs");
var _Search = require("../Search");
var _Table = require("../Table");
var _reducer = require("./reducer");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const defaultLocalization = {
  nextPage: 'Next page',
  previousPage: 'Previous page',
  search: 'Search'
};
const swapArrayElements = (array, sourceIndex, destinationIndex) => {
  const smallerIndex = Math.min(sourceIndex, destinationIndex);
  const largerIndex = Math.max(sourceIndex, destinationIndex);
  return [...array.slice(0, smallerIndex), ...(sourceIndex < destinationIndex ? array.slice(smallerIndex + 1, largerIndex + 1) : []), array[sourceIndex], ...(sourceIndex > destinationIndex ? array.slice(smallerIndex, largerIndex) : []), ...array.slice(largerIndex + 1)];
};
const InternalStatefulTable = _ref => {
  let {
    columns = [],
    defaultSelected = [],
    itemName,
    items = [],
    keyField,
    localization: localizationProp = defaultLocalization,
    getRangeLabel,
    onSelectionChange,
    onRowDrop,
    search,
    pagination = false,
    filters,
    selectable = false,
    stickyHeader = false,
    ...rest
  } = _ref;
  const localization = {
    ...defaultLocalization,
    ...localizationProp
  };
  const reducer = (0, _react.useMemo)(() => (0, _reducer.createReducer)(), []);
  const reducerInit = (0, _react.useMemo)(() => (0, _reducer.createReducerInit)(), []);
  const sortable = (0, _react.useMemo)(() => columns.some(column => column.sortKey || column.sortFn), [columns]);
  const [state, dispatch] = (0, _react.useReducer)(reducer, {
    columns,
    defaultSelected,
    items,
    pagination,
    filters,
    search
  }, reducerInit);
  const columnsChangedCallback = (0, _react.useCallback)(() => dispatch({
    type: 'COLUMNS_CHANGED',
    columns
  }), [columns]);
  const itemsChangedCallback = (0, _react.useCallback)(() => dispatch({
    type: 'ITEMS_CHANGED',
    items,
    isPaginationEnabled: pagination
  }), [items, pagination]);
  (0, _hooks.useDidUpdate)(columnsChangedCallback);
  (0, _hooks.useDidUpdate)(itemsChangedCallback);
  const onPageChange = (0, _react.useCallback)(page => dispatch({
    type: 'PAGE_CHANGE',
    page
  }), []);
  const onItemsPerPageChange = (0, _react.useCallback)(itemsPerPage => dispatch({
    type: 'ITEMS_PER_PAGE_CHANGE',
    itemsPerPage
  }), []);
  const onItemSelect = (0, _react.useCallback)(selectedItems => {
    dispatch({
      type: 'SELECTED_ITEMS',
      selectedItems
    });
    if (typeof onSelectionChange === 'function') {
      onSelectionChange(selectedItems);
    }
  }, [onSelectionChange]);
  const onSort = (0, _react.useCallback)((_columnHash, direction, column) => {
    dispatch({
      type: 'SORT',
      column,
      direction
    });
  }, []);
  const paginationOptions = (0, _react.useMemo)(() => pagination ? {
    ...state.pagination,
    onItemsPerPageChange,
    onPageChange,
    localization: {
      previousPage: localization.previousPage,
      nextPage: localization.nextPage
    },
    getRangeLabel
  } : undefined, [pagination, state.pagination, getRangeLabel, onItemsPerPageChange, onPageChange, localization.previousPage, localization.nextPage]);
  const selectableOptions = (0, _react.useMemo)(() => selectable ? {
    selectedItems: state.selectedItems,
    onSelectionChange: onItemSelect
  } : undefined, [selectable, state.selectedItems, onItemSelect]);
  const sortableOptions = (0, _react.useMemo)(() => sortable ? {
    ...state.sortable,
    onSort
  } : undefined, [sortable, state.sortable, onSort]);
  const onDragEnd = (0, _react.useCallback)((from, to) => {
    const updatedItems = swapArrayElements(state.currentItems, from, to);
    dispatch({
      type: 'ITEMS_CHANGED',
      items: updatedItems,
      isPaginationEnabled: pagination
    });
    if (typeof onRowDrop === 'function') {
      onRowDrop(updatedItems);
    }
  }, [state.currentItems, onRowDrop, pagination]);
  (0, _react.useEffect)(() => {
    if (!filters) {
      return;
    }
    const pillTabsProps = {
      activePills: state.activePills,
      onPillClick: pillId => {
        dispatch({
          type: 'TOGGLE_PILL',
          pillId,
          filter: filters.filter
        });
      },
      items: filters.pillTabs
    };
    dispatch({
      type: 'SET_PILL_TABS_PROPS',
      pillTabsProps
    });
  }, [filters, state.activePills, search]);
  const searchProps = (0, _react.useMemo)(() => search ? {
    value: state.searchValue,
    onChange: e => dispatch({
      type: 'SEARCH_VALUE_CHANGE',
      value: e.target.value
    }),
    onSubmit: () => dispatch({
      type: 'ON_SEARCH_SUBMIT',
      filterPills: filters?.filter
    })
  } : undefined, [search, state.searchValue, filters]);
  const renderPills = () => {
    if (!filters || !state.pillTabsProps) {
      return null;
    }
    return /*#__PURE__*/_react.default.createElement(_Box.Box, {
      marginBottom: "medium"
    }, /*#__PURE__*/_react.default.createElement(_PillTabs.PillTabs, state.pillTabsProps));
  };
  const renderSearch = () => {
    if (!search || !searchProps) {
      return;
    }
    return /*#__PURE__*/_react.default.createElement(_Box.Box, {
      marginBottom: "medium"
    }, /*#__PURE__*/_react.default.createElement(_Search.Search, (0, _extends2.default)({
      localization: {
        search: localization.search
      }
    }, searchProps)));
  };
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, renderPills(), renderSearch(), /*#__PURE__*/_react.default.createElement(_Table.Table, (0, _extends2.default)({}, rest, {
    columns: state.columns,
    itemName: itemName,
    items: state.currentItems,
    keyField: keyField,
    onRowDrop: onRowDrop ? onDragEnd : undefined,
    pagination: paginationOptions,
    selectable: selectableOptions,
    sortable: sortableOptions,
    stickyHeader: stickyHeader
  })));
};
const StatefulTable = (0, _utils.typedMemo)(InternalStatefulTable);
exports.StatefulTable = StatefulTable;