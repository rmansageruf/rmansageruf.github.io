"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cell = void 0;
var _react = _interopRequireWildcard(require("react"));
var _utils = require("../../../utils");
var _Tooltip = require("../../Tooltip");
var _Typography = require("../../Typography");
var _editors = require("../editors");
var _hooks = require("../hooks");
var _utils2 = require("../utils");
var _styled = require("./styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const InternalCell = _ref => {
  let {
    columnIndex,
    disabled = false,
    formatting,
    hash,
    options,
    rowIndex,
    type,
    rowId,
    validation,
    notation,
    value,
    nextRowValue,
    isChild,
    isLastChild
  } = _ref;
  const cell = (0, _react.useMemo)(() => ({
    columnIndex,
    disabled,
    hash,
    rowIndex,
    type,
    value
  }), [columnIndex, disabled, hash, rowIndex, type, value]);
  const cellIdx = (0, _react.useMemo)(() => (0, _utils2.getCellIdx)(cell), [cell]);
  const {
    handleBlur,
    handleChange,
    handleDoubleClick,
    handleKeyDown,
    isEditing
  } = (0, _hooks.useEditableCell)(cell);
  const {
    store,
    useStore
  } = (0, _hooks.useWorksheetStore)();
  const {
    isAutoFillActive,
    onFillFullColumn,
    setIsMouseDown,
    setSelectingActive,
    setBlockFillOut,
    setSelectedCell: setHighlightedCell
  } = (0, _hooks.useAutoFilling)(cell);
  const tooltipId = (0, _react.useId)();
  const setSelectedRows = useStore(store, state => state.setSelectedRows);
  const setSelectedCells = useStore(store, state => state.setSelectedCells);
  const addInvalidCells = useStore(store, state => state.addInvalidCells);
  const removeInvalidCells = useStore(store, state => state.removeInvalidCells);
  const row = useStore(store, (0, _react.useMemo)(() => state => state.rows[rowIndex], [rowIndex]));
  const editWithValue = useStore(store, (0, _react.useMemo)(() => state => state.editWithValue, []));
  const isShiftPressed = useStore(store, (0, _react.useMemo)(() => state => state.isShiftPressed, []));
  const isMetaKey = useStore(store, state => state.isMetaKey);
  const isControlKey = useStore(store, state => state.isControlKey);
  const {
    selectedCells,
    isLastSelected,
    isFirstSelected,
    isSelected
  } = useStore(store, (0, _react.useMemo)(() => state => {
    const idx = Object.keys(state.selectedCellsMap).indexOf(cellIdx);
    return {
      selectedCells: state.selectedCells,
      isLastSelected: state.selectedCells.length - 1 === idx,
      isFirstSelected: idx === 0,
      isSelected: idx !== -1
    };
  }, [cellIdx]));
  const isEdited = useStore(store, (0, _react.useMemo)(() => state => !!state.editedCellsMap[cellIdx], [cellIdx]));
  const invalidCell = useStore(store, (0, _react.useMemo)(() => state => state.invalidCellsMap[cellIdx], [cellIdx]));
  const isValid = (0, _react.useMemo)(() => typeof validation === 'function' ? validation(value) : true, [validation, value]);
  const isNextCellValid = (0, _react.useMemo)(() => typeof validation === 'function' ? validation(nextRowValue) : true, [nextRowValue, validation]);
  (0, _react.useEffect)(() => {
    // Remove from invalidCells if new value is valid
    if (isValid && invalidCell) {
      removeInvalidCells([cell]);
    }

    // Add to invalidCells but only if value is different
    if (!isValid && (!invalidCell || invalidCell.value !== cell.value)) {
      addInvalidCells([cell]);
    }
  }, [addInvalidCells, cell, isValid, invalidCell, removeInvalidCells]);
  const handleAutoFilldblClick = (0, _react.useCallback)(event => {
    event.stopPropagation();
    onFillFullColumn();
  }, [onFillFullColumn]);
  const handleClick = (0, _react.useCallback)(() => {
    if (isShiftPressed) {
      const lastSelected = selectedCells[selectedCells.length - 1];
      const fromIdx = lastSelected.rowIndex;
      const toIdx = cell.rowIndex;
      const rangeIdxs = Array.from({
        length: toIdx - fromIdx
      }, (_, index) => fromIdx + index + 1);
      const newCells = rangeIdxs.map(rowIndex => ({
        ...cell,
        columnIndex: lastSelected.columnIndex,
        rowIndex
      }));
      setSelectedCells([...selectedCells, ...newCells]);
    } else {
      setSelectedRows([rowIndex]);
      setSelectedCells([cell]);
    }
  }, [cell, isShiftPressed, rowIndex, selectedCells, setSelectedCells, setSelectedRows]);
  const renderedValue = (0, _react.useMemo)(() => {
    if (typeof formatting === 'function' && value !== '' && !Number.isNaN(value)) {
      return formatting(value);
    }
    return `${value}`;
  }, [formatting, value]);
  const renderedCell = (0, _react.useMemo)(() => {
    switch (type) {
      case 'select':
        return /*#__PURE__*/_react.default.createElement(_editors.SelectEditor, {
          cell: cell,
          isEditing: isEditing,
          onBlur: handleBlur,
          onChange: handleChange,
          options: options
        });
      case 'checkbox':
        return /*#__PURE__*/_react.default.createElement(_editors.CheckboxEditor, {
          cell: cell,
          onBlur: handleBlur,
          onChange: handleChange,
          toggle: isEditing
        });
      case 'modal':
        return /*#__PURE__*/_react.default.createElement(_editors.ModalEditor, {
          cell: cell,
          formatting: formatting,
          isEditing: isEditing
        });
      case 'toggle':
        return /*#__PURE__*/_react.default.createElement(_editors.ToggleEditor, {
          rowId: rowId,
          toggle: isEditing
        });
      default:
        return isEditing && !disabled ? /*#__PURE__*/_react.default.createElement(_editors.TextEditor, {
          cell: cell,
          initialValue: editWithValue,
          isControlKey: isControlKey,
          isEdited: isEdited,
          isMetaKey: isMetaKey,
          onBlur: handleBlur,
          onKeyDown: handleKeyDown
        }) : /*#__PURE__*/_react.default.createElement(_Typography.Small, {
          color: disabled ? 'secondary50' : 'secondary70',
          ellipsis: true,
          title: renderedValue
        }, renderedValue);
    }
  }, [type, cell, handleBlur, handleChange, options, isEditing, formatting, rowId, disabled, editWithValue, isControlKey, isEdited, isMetaKey, handleKeyDown, renderedValue]);
  const renderedNote = (0, _react.useMemo)(() => {
    if (!notation) {
      return null;
    }
    const note = notation(value, row);
    if (!note) {
      return null;
    }
    return /*#__PURE__*/_react.default.createElement(_Tooltip.Tooltip, {
      id: tooltipId,
      placement: "right",
      trigger: /*#__PURE__*/_react.default.createElement(_styled.CellNote, {
        color: note.color,
        role: "note"
      })
    }, note.description);
  }, [notation, row, tooltipId, value]);
  const renderedAutoFillHandler = (0, _react.useMemo)(() => {
    return isLastSelected ? /*#__PURE__*/_react.default.createElement(_styled.AutoFillHandler, {
      "aria-label": "Autofill handler",
      isVisible: !isAutoFillActive,
      onDoubleClick: handleAutoFilldblClick,
      onMouseDown: event => {
        event.stopPropagation();
        setSelectingActive(false);
        setBlockFillOut(false);
        setIsMouseDown(true);
      }
    }) : null;
  }, [handleAutoFilldblClick, isAutoFillActive, isLastSelected, setBlockFillOut, setIsMouseDown, setSelectingActive]);
  return /*#__PURE__*/_react.default.createElement(_styled.StyledCell, {
    isChild: isChild,
    isEdited: isEdited,
    isFirstSelected: isFirstSelected,
    isLastChild: isLastChild,
    isLastSelected: isLastSelected,
    isNextCellValid: isNextCellValid,
    isSelected: isSelected,
    isValid: isValid,
    onClick: handleClick,
    onDoubleClick: handleDoubleClick,
    onMouseDown: () => {
      handleClick();
      setSelectingActive(true);
      setBlockFillOut(true);
    },
    onMouseEnter: setHighlightedCell,
    onMouseUp: () => {
      setIsMouseDown(false);
      setSelectingActive(false);
    },
    type: type
  }, renderedCell, renderedAutoFillHandler, renderedNote);
};
const Cell = (0, _utils.typedMemo)(InternalCell);
exports.Cell = Cell;