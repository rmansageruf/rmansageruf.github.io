"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TreeNode = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _bigDesignIcons = require("@bigcommerce/big-design-icons");
var _react = _interopRequireWildcard(require("react"));
var _utils = require("../../../utils");
var _private = require("../../Checkbox/private");
var _styled = require("../../Radio/styled");
var _useSelectedChildrenCount = require("../hooks/useSelectedChildrenCount");
var _styled2 = require("../styled");
var _Tree = require("../Tree");
var _styled3 = require("./styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const flexItemProps = {
  flexShrink: 0,
  marginLeft: 'xxSmall'
};
const InternalTreeNode = _ref => {
  let {
    children,
    icon,
    label,
    value,
    id
  } = _ref;
  const {
    disabledNodes,
    expandable,
    focusable,
    iconless,
    onKeyDown,
    onNodeClick,
    selectable,
    treeRef
  } = (0, _react.useContext)(_Tree.TreeContext);
  const nodeRef = (0, _react.useRef)(null);
  const selectableRef = (0, _react.useRef)(null);
  const isExpanded = expandable.expandedNodes.includes(id);
  const isSelected = selectable?.selectedNodes?.includes(id);
  const isDisabled = disabledNodes?.includes(id);
  const isSelectable = value !== undefined && selectable?.type !== undefined && !isDisabled;
  const selectedChildrenCount = (0, _useSelectedChildrenCount.useSelectedChildrenCount)({
    selectedNodes: selectable?.selectedNodes,
    children
  });
  (0, _react.useEffect)(() => {
    if (focusable.focusedNode === id && nodeRef.current !== document.activeElement && document.activeElement !== document.body && treeRef.current?.contains(document.activeElement)) {
      nodeRef.current?.focus();
    }
  }, [focusable, id, treeRef]);

  // Could be multiple elements in which are clicked.
  // Typing to generic Element type since all other elements extend from it.
  const handleNodeToggle = (0, _react.useCallback)(async e => {
    // Prevents the collapse/expand when clicking on a radio or checkbox
    // Checks to see if every element inside the selectableRef gets clicked.
    if (e?.target instanceof Node && selectableRef.current?.contains(e.target) || children === undefined) {
      return;
    }
    if (typeof expandable.onToggle === 'function') {
      expandable.onToggle(id, isExpanded);
    }
    if (isExpanded) {
      if (typeof expandable.onCollapse === 'function') {
        expandable.onCollapse(id);
      }
    } else if (typeof expandable.onExpand === 'function') {
      expandable.onExpand(id);
    }
  }, [children, id, expandable, isExpanded]);
  const handleNodeSelected = (0, _react.useCallback)(() => {
    if (!isSelectable) {
      return;
    }
    if (typeof selectable.onSelect === 'function') {
      selectable.onSelect(id, value);
    }
  }, [id, isSelectable, selectable, value]);
  const handleKeyEvent = (0, _react.useCallback)(e => {
    if (e.altKey || e.currentTarget !== e.target) {
      return;
    }
    onKeyDown(e, {
      id,
      isExpanded,
      isSelectable,
      hasChildren: !!children?.length,
      value
    });
  }, [children, id, isExpanded, isSelectable, onKeyDown, value]);
  const handleNodeClick = (0, _react.useCallback)(e => {
    // Prevents event bubbling
    e.stopPropagation();
    if (typeof focusable.onFocus === 'function') {
      focusable.onFocus(id);
    }
    if (typeof onNodeClick === 'function') {
      onNodeClick(e, id);
    }
  }, [focusable, id, onNodeClick]);
  const additionalProps = (0, _react.useMemo)(() => selectable?.type ? {
    'aria-selected': isSelected
  } : {}, [selectable, isSelected]);
  const renderedArrow = (0, _react.useMemo)(() => children ? /*#__PURE__*/_react.default.createElement(_styled3.StyledArrowWrapper, {
    expanded: isExpanded,
    flexShrink: 0
  }, /*#__PURE__*/_react.default.createElement(_bigDesignIcons.ChevronRightIcon, {
    color: "secondary60",
    focusable: false,
    size: "xLarge"
  })) : /*#__PURE__*/_react.default.createElement(_styled3.StyledGap, null), [children, isExpanded]);
  const renderedChildren = (0, _react.useMemo)(() => children && /*#__PURE__*/_react.default.createElement(_styled2.StyledUl, {
    role: "group",
    show: isExpanded
  }, children.map((child, index) => /*#__PURE__*/_react.default.createElement(TreeNode, (0, _extends2.default)({}, child, {
    key: index
  })))), [children, isExpanded]);
  const renderedIcon = (0, _react.useMemo)(() => {
    if (iconless) {
      return null;
    }
    return icon ? /*#__PURE__*/_react.default.createElement(_styled3.StyledFlexItem, flexItemProps, icon) : /*#__PURE__*/_react.default.createElement(_styled3.StyledFlexItem, flexItemProps, /*#__PURE__*/_react.default.createElement(_bigDesignIcons.FolderIcon, {
      color: isDisabled ? 'primary20' : 'primary30',
      size: "xLarge"
    }));
  }, [isDisabled, icon, iconless]);
  const renderedSelectable = (0, _react.useMemo)(() => {
    if (value === undefined || !selectable?.type) {
      return null;
    }
    if (selectable.type === 'radio') {
      return /*#__PURE__*/_react.default.createElement(_styled3.StyledSelectableWrapper, flexItemProps, /*#__PURE__*/_react.default.createElement(_styled.StyledRadio, {
        "aria-hidden": true,
        checked: isSelected,
        disabled: isDisabled,
        onClick: handleNodeSelected,
        ref: selectableRef
      }));
    }
    if (selectable.type === 'multi') {
      return /*#__PURE__*/_react.default.createElement(_styled3.StyledSelectableWrapper, flexItemProps, /*#__PURE__*/_react.default.createElement(_private.StyledCheckbox, {
        "aria-hidden": true,
        checked: isSelected,
        disabled: isDisabled,
        onClick: handleNodeSelected,
        ref: selectableRef
      }, isSelected ? /*#__PURE__*/_react.default.createElement(_bigDesignIcons.CheckIcon, null) : null));
    }
  }, [isDisabled, handleNodeSelected, isSelected, selectable, value]);
  return (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_styled3.StyledLi, (0, _extends2.default)({
    "aria-expanded": isExpanded,
    onClick: handleNodeClick,
    onKeyDown: handleKeyEvent,
    ref: nodeRef,
    role: "treeitem",
    tabIndex: focusable.focusedNode === id ? 0 : -1
  }, additionalProps), /*#__PURE__*/_react.default.createElement(_styled3.StyledFlex, {
    alignItems: "center",
    flexDirection: "row",
    onClick: handleNodeToggle,
    selected: isSelected
  }, renderedArrow, renderedSelectable, renderedIcon, /*#__PURE__*/_react.default.createElement(_styled3.StyledText, {
    as: "span",
    color: isDisabled ? 'secondary50' : 'secondary70',
    ellipsis: true,
    marginLeft: "xxSmall"
  }, label, selectedChildrenCount ? /*#__PURE__*/_react.default.createElement(_styled3.StyledText, {
    as: "span",
    color: "primary"
  }, ' ', "(", selectedChildrenCount, ")") : null)), renderedChildren), [additionalProps, handleKeyEvent, handleNodeClick, handleNodeToggle, id, isDisabled, isExpanded, isSelected, focusable, label, renderedArrow, renderedChildren, renderedSelectable, renderedIcon, selectedChildrenCount]);
};
const TreeNode = (0, _utils.typedMemo)(InternalTreeNode);
exports.TreeNode = TreeNode;