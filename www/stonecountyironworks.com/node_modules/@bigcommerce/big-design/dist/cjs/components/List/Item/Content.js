"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Content = void 0;
var _react = _interopRequireWildcard(require("react"));
var _Flex = require("../../Flex");
var _Tooltip = require("../../Tooltip");
var _Typography = require("../../Typography");
var _styled = require("./styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const Content = /*#__PURE__*/(0, _react.memo)(_ref => {
  let {
    item,
    isHighlighted
  } = _ref;
  const iconColor = (0, _react.useMemo)(() => {
    if (item.disabled) {
      return 'secondary40';
    }
    if (!isHighlighted || !('onActionClick' in item)) {
      return 'secondary60';
    }
    return 'actionType' in item && item.actionType ? 'danger50' : 'primary';
  }, [isHighlighted, item]);
  const renderIcon = (0, _react.useMemo)(() => /*#__PURE__*/(0, _react.isValidElement)(item.icon) && /*#__PURE__*/(0, _react.cloneElement)(item.icon, {
    color: iconColor,
    size: 'large'
  }), [iconColor, item]);
  const descriptionColor = (0, _react.useCallback)(isDisabled => isDisabled ? 'secondary40' : 'secondary60', []);
  const wrapInLink = (0, _react.useCallback)((linkItem, content) => /*#__PURE__*/_react.default.createElement(_styled.StyledLink, {
    href: linkItem.url,
    tabIndex: -1,
    target: linkItem.target
  }, content), []);
  const wrapInTooltip = (0, _react.useCallback)((tooltip, tooltipTrigger) => /*#__PURE__*/_react.default.createElement(_Tooltip.Tooltip, {
    modifiers: [{
      name: 'preventOverflow'
    }, {
      name: 'offset',
      options: {
        offset: [0, 20]
      }
    }],
    placement: "left",
    trigger: tooltipTrigger
  }, tooltip), []);
  const getContent = (0, _react.useMemo)(() => {
    const {
      content,
      disabled,
      description,
      icon
    } = item;
    const baseContent = /*#__PURE__*/_react.default.createElement(_Flex.Flex, {
      alignItems: "center",
      flexDirection: "row"
    }, icon && /*#__PURE__*/_react.default.createElement(_Flex.FlexItem, {
      alignSelf: description ? 'flex-start' : undefined,
      paddingRight: "xSmall",
      paddingTop: description ? 'xSmall' : undefined
    }, renderIcon), description ? /*#__PURE__*/_react.default.createElement(_Flex.FlexItem, {
      paddingVertical: "xSmall"
    }, content, /*#__PURE__*/_react.default.createElement(_Typography.Small, {
      color: descriptionColor(disabled)
    }, description)) : content);
    const finalContent = 'type' in item && item.type === 'link' && !disabled ? wrapInLink(item, baseContent) : baseContent;
    return disabled && 'tooltip' in item && item.tooltip ? wrapInTooltip(item.tooltip, finalContent) : finalContent;
  }, [descriptionColor, item, renderIcon, wrapInLink, wrapInTooltip]);
  return getContent;
});
exports.Content = Content;