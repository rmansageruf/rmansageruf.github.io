"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Popover = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _reactPopper = require("react-popper");
var _mixins = require("../../mixins");
var _Box = require("../Box");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const Popover = _ref => {
  let {
    anchorElement,
    children,
    isOpen,
    role = 'dialog',
    ...props
  } = _ref;
  const uniquePopoverId = (0, _react.useId)();
  const rest = (0, _mixins.excludeMarginProps)(props);
  (0, _react.useEffect)(() => {
    if (!anchorElement) {
      return;
    }
    anchorElement.setAttribute('aria-controls', uniquePopoverId);
    anchorElement.setAttribute('aria-expanded', String(isOpen));
    anchorElement.setAttribute('aria-haspopup', role);
  }, [anchorElement, isOpen, role, uniquePopoverId]);
  return isOpen ? /*#__PURE__*/_react.default.createElement(InternalPopover, (0, _extends2.default)({
    anchorElement: anchorElement
  }, rest, {
    id: uniquePopoverId
  }), children) : null;
};
exports.Popover = Popover;
// We use an Internal component that mounts/unmounts on isOpen
// This facilitates running cleanups on some effects.
const InternalPopover = _ref2 => {
  let {
    anchorElement,
    children,
    closeOnClickOutside = true,
    closeOnEscKey = true,
    id,
    label,
    matchAnchorElementWidth = false,
    skidding = 0,
    distance = 4,
    onClose = () => null,
    placement = 'auto',
    role,
    ...props
  } = _ref2;
  const [popperElement, setPopperElement] = (0, _react.useState)(null);
  const previousFocus = (0, _react.useRef)(typeof document !== 'undefined' ? document.activeElement : null);
  const popperModifiers = (0, _react.useMemo)(() => [{
    name: 'offset',
    options: {
      offset: [skidding, distance]
    }
  }, {
    name: 'sameWidth',
    enabled: matchAnchorElementWidth,
    phase: 'beforeWrite',
    requires: ['computeStyles'],
    fn(_ref3) {
      let {
        state
      } = _ref3;
      state.styles.popper.width = `${state.rects.reference.width}px`;
    },
    effect(_ref4) {
      let {
        state
      } = _ref4;
      const element = state.elements.reference;
      if (element instanceof HTMLElement) {
        state.elements.popper.style.width = `${element.offsetWidth}px`;
      }
    }
  }], [skidding, distance, matchAnchorElementWidth]);
  const {
    styles,
    attributes
  } = (0, _reactPopper.usePopper)(anchorElement, popperElement, {
    modifiers: popperModifiers,
    placement
  });
  (0, _react.useEffect)(() => {
    const prevFocus = previousFocus.current;
    return () => {
      if (prevFocus instanceof HTMLElement) {
        prevFocus.focus();
      }
    };
  }, []);

  // Setup close on click outside
  (0, _react.useEffect)(() => {
    if (typeof document === 'undefined' || !closeOnClickOutside) {
      return;
    }
    const clickHandler = event => {
      if (!(event.target instanceof Element)) {
        return;
      }
      if (popperElement?.contains(event.target)) {
        return;
      }
      if (anchorElement?.contains(event.target)) {
        return;
      }
      onClose();
    };
    document.addEventListener('click', clickHandler);
    return () => {
      document.removeEventListener('click', clickHandler);
    };
  }, [anchorElement, closeOnClickOutside, onClose, popperElement]);

  // Setup close on Esc key
  (0, _react.useEffect)(() => {
    if (typeof document === 'undefined' || !closeOnEscKey) {
      return;
    }
    const keydownHandler = event => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('keydown', keydownHandler);
    return () => {
      document.removeEventListener('keydown', keydownHandler);
    };
  }, [closeOnEscKey, onClose]);
  return /*#__PURE__*/_react.default.createElement(_Box.Box, (0, _extends2.default)({
    "aria-label": label,
    backgroundColor: "white",
    padding: "medium",
    role: role,
    shadow: "floating",
    tabIndex: -1,
    zIndex: "popover"
  }, props, attributes.popper, {
    id: id,
    ref: setPopperElement,
    style: styles.popper
  }), children);
};