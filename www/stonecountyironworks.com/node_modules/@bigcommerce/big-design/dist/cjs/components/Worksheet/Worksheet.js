"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorksheetLocalizationContext = exports.WorksheetContext = exports.Worksheet = void 0;
var _bigDesignIcons = require("@bigcommerce/big-design-icons");
var _react = _interopRequireWildcard(require("react"));
var _utils = require("../../utils");
var _Box = require("../Box");
var _Tooltip = require("../Tooltip");
var _context = require("./context");
var _hooks = require("./hooks");
var _Modal = require("./Modal/Modal");
var _Row = require("./Row");
var _styled = require("./RowStatus/styled");
var _styled2 = require("./styled");
var _utils2 = require("./utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const InternalWorksheet = (0, _utils.typedMemo)(_ref => {
  let {
    columns,
    expandableRows,
    defaultExpandedRows,
    disabledRows,
    items,
    minWidth,
    onChange,
    onErrors
  } = _ref;
  const tableRef = /*#__PURE__*/(0, _react.createRef)();
  const shouldBeTriggeredOnChange = (0, _react.useRef)(false);
  const {
    store,
    useStore
  } = (0, _hooks.useWorksheetStore)();
  const tooltipId = (0, _react.useId)();
  const setRows = useStore(store, state => state.setRows);
  const setColumns = useStore(store, state => state.setColumns);
  const setExpandableRows = useStore(store, state => state.setExpandableRows);
  const setDisabledRows = useStore(store, state => state.setDisabledRows);
  const setTableRef = useStore(store, state => state.setTableRef);
  const resetInvalidCells = useStore(store, state => state.resetInvalidCells);
  const rows = useStore(store, (0, _react.useMemo)(() => state => state.rows, []));
  const editedCells = useStore(store, (0, _react.useMemo)(() => state => state.editedCells, []));
  const invalidCells = useStore(store, (0, _react.useMemo)(() => state => state.invalidCells, []));
  const {
    handleKeyDown,
    handleKeyUp
  } = (0, _hooks.useKeyEvents)();

  // Add a column for the toggle components
  const expandedColumns = (0, _react.useMemo)(() => {
    return expandableRows ? [{
      hash: '',
      header: '',
      type: 'toggle',
      width: 32
    }, ...columns] : columns;
  }, [columns, expandableRows]);
  (0, _react.useEffect)(() => {
    shouldBeTriggeredOnChange.current = editedCells.length > 0;
  }, [editedCells]);

  // Create a new reference since state mutates rows to prevent unecessary rerendering
  (0, _react.useEffect)(() => {
    shouldBeTriggeredOnChange.current = false;
    resetInvalidCells();
    setRows([...items]);
  }, [items, resetInvalidCells, setRows]);
  (0, _react.useEffect)(() => setColumns(expandedColumns), [expandedColumns, setColumns]);
  (0, _react.useEffect)(() => setExpandableRows(expandableRows || {}, defaultExpandedRows || []), [expandableRows, defaultExpandedRows, setExpandableRows]);
  (0, _react.useEffect)(() => setDisabledRows(disabledRows || []), [disabledRows, setDisabledRows]);
  (0, _react.useEffect)(() => setTableRef(tableRef.current), [setTableRef, tableRef]);
  (0, _react.useEffect)(() => {
    if (editedCells.length && shouldBeTriggeredOnChange.current) {
      onChange((0, _utils2.editedRows)(editedCells, rows));
    }
  }, [editedCells, onChange, rows]);
  (0, _react.useEffect)(() => {
    if (typeof onErrors === 'function' && invalidCells.length) {
      onErrors((0, _utils2.invalidRows)(invalidCells, rows));
    }
  }, [invalidCells, onErrors, rows]);
  const getRenderedTooltip = (0, _react.useCallback)(tooltip => {
    if (typeof tooltip === 'string' && tooltip.length > 0) {
      return /*#__PURE__*/_react.default.createElement(_Tooltip.Tooltip, {
        id: tooltipId,
        placement: "right",
        trigger: /*#__PURE__*/_react.default.createElement(_Box.Box, {
          as: "span",
          marginLeft: "xxSmall"
        }, /*#__PURE__*/_react.default.createElement(_bigDesignIcons.BaselineHelpIcon, {
          "aria-describedby": tooltipId,
          size: "medium",
          title: "Hover or focus for additional context."
        }))
      }, tooltip);
    }
    return null;
  }, [tooltipId]);
  const renderedHeaders = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement("thead", null, /*#__PURE__*/_react.default.createElement("tr", null, /*#__PURE__*/_react.default.createElement(_styled.Status, null), expandedColumns.map((column, index) => /*#__PURE__*/_react.default.createElement(_styled2.Header, {
    columnType: column.type,
    columnWidth: column.width || 'auto',
    key: index
  }, column.header, " ", getRenderedTooltip(column.tooltip))))), [expandedColumns, getRenderedTooltip]);
  const tableHasStaticWidth = (0, _react.useMemo)(() => expandedColumns.every(column => column.width && typeof column.width === 'number'), [expandedColumns]);
  const renderedRows = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement("tbody", null, rows.map((_row, rowIndex) => /*#__PURE__*/_react.default.createElement(_Row.Row, {
    columns: expandedColumns,
    key: rowIndex,
    rowIndex: rowIndex
  }))), [expandedColumns, rows]);
  const renderedModals = (0, _react.useMemo)(() => expandedColumns.filter(column => column.type === 'modal').map((column, index) => /*#__PURE__*/_react.default.createElement(_Modal.WorksheetModal, {
    column: column,
    key: index
  })), [expandedColumns]);
  return /*#__PURE__*/_react.default.createElement(_context.UpdateItemsProvider, {
    items: rows
  }, /*#__PURE__*/_react.default.createElement(_styled2.StyledBox, null, /*#__PURE__*/_react.default.createElement(_styled2.Table, {
    hasExpandableRows: Boolean(expandableRows),
    hasStaticWidth: tableHasStaticWidth,
    minWidth: minWidth,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    ref: tableRef,
    tabIndex: 0
  }, renderedHeaders, renderedRows)), renderedModals);
});
const WorksheetContext = /*#__PURE__*/(0, _react.createContext)(null);
exports.WorksheetContext = WorksheetContext;
const WorksheetLocalizationContext = /*#__PURE__*/(0, _react.createContext)({
  toggleRowExpanded: 'toggle row expanded'
});
exports.WorksheetLocalizationContext = WorksheetLocalizationContext;
const defaultLocalization = {
  toggleRowExpanded: 'toggle row expanded'
};
const Worksheet = (0, _utils.typedMemo)(_ref2 => {
  let {
    localization = defaultLocalization,
    ...props
  } = _ref2;
  const store = (0, _react.useMemo)(() => (0, _hooks.createWorksheetStore)(), []);
  return /*#__PURE__*/_react.default.createElement(WorksheetContext.Provider, {
    value: store
  }, /*#__PURE__*/_react.default.createElement(WorksheetLocalizationContext.Provider, {
    value: localization
  }, /*#__PURE__*/_react.default.createElement(InternalWorksheet, props)));
});
exports.Worksheet = Worksheet;