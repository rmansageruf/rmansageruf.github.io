"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEditableCell = void 0;
var _react = require("react");
var _useTableFocus = require("../useTableFocus");
var _useUpdateItems = require("../useUpdateItems");
var _useWorksheetStore = require("../useWorksheetStore");
const useEditableCell = cell => {
  const {
    store,
    useStore
  } = (0, _useWorksheetStore.useWorksheetStore)();
  const setEditingCell = useStore(store, state => state.setEditingCell);
  const {
    updateItems
  } = (0, _useUpdateItems.useUpdateItems)();
  const {
    focusTable
  } = (0, _useTableFocus.useTableFocus)();
  const isEditing = useStore(store, (0, _react.useMemo)(() => _ref => {
    let {
      editingCell
    } = _ref;
    return editingCell !== null && editingCell.columnIndex === cell.columnIndex && editingCell.rowIndex === cell.rowIndex;
  }, [cell]));
  const restoreFocus = (0, _react.useCallback)(() => {
    setEditingCell({
      cell: null
    });
    focusTable();
  }, [focusTable, setEditingCell]);
  const handleDoubleClick = (0, _react.useCallback)(() => {
    if (!cell.disabled) {
      setEditingCell({
        cell
      });
    }
  }, [cell, setEditingCell]);
  const handleBlur = (0, _react.useCallback)((event, cell) => {
    const isNumberCell = cell?.type === 'number';
    const isTextCell = cell?.type === 'text';
    if (isNumberCell || isTextCell) {
      updateItems([cell], [isNumberCell ? Number(event?.target.value) : event?.target.value]);
    }
    restoreFocus();
  }, [restoreFocus, updateItems]);
  const handleChange = (0, _react.useCallback)(newValue => {
    updateItems([cell], [newValue]);
    restoreFocus();
  }, [cell, restoreFocus, updateItems]);
  const handleKeyDown = (0, _react.useCallback)((event, newValue) => {
    const key = event.key;
    switch (key) {
      case 'Enter':
      case 'Tab':
        event.preventDefault();

        // Only call updateItems if cells have new values
        if (cell.value !== newValue) {
          updateItems([cell], [newValue]);
        }
        restoreFocus();
        break;
      case 'Escape':
        event.preventDefault();
        restoreFocus();
        break;
    }
  }, [cell, restoreFocus, updateItems]);
  return (0, _react.useMemo)(() => ({
    handleBlur,
    handleChange,
    handleDoubleClick,
    handleKeyDown,
    isEditing
  }), [handleBlur, handleChange, handleDoubleClick, handleKeyDown, isEditing]);
};
exports.useEditableCell = useEditableCell;