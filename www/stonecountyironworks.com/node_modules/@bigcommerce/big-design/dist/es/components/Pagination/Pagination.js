import { ArrowDropDownIcon, ChevronLeftIcon, ChevronRightIcon } from '@bigcommerce/big-design-icons';
import React, { memo, useCallback, useEffect, useState } from 'react';
import { Dropdown } from '../Dropdown';
import { Flex, FlexItem } from '../Flex';
import { StyledButton } from './styled';
const defaultLocalization = {
  previousPage: 'Previous page',
  nextPage: 'Next page'
};
const defaultGetRangeLabel = (start, end, totalItems) => {
  if (start === end) {
    return `${start} of ${totalItems}`;
  }
  return `${start} - ${end} of ${totalItems}`;
};
export const Pagination = /*#__PURE__*/memo(_ref => {
  let {
    itemsPerPage,
    currentPage,
    totalItems,
    itemsPerPageOptions = [],
    onPageChange,
    onItemsPerPageChange,
    label = 'pagination',
    localization = defaultLocalization,
    getRangeLabel = defaultGetRangeLabel
  } = _ref;
  const [maxPages, setMaxPages] = useState(Math.max(1, Math.ceil(totalItems / itemsPerPage)));
  const [itemRange, setItemRange] = useState({
    start: 0,
    end: 0
  });
  const handlePageOutOfBounds = useCallback(() => {
    if (currentPage < 1 || isNaN(currentPage) || currentPage === undefined) {
      onPageChange(1);
    } else if (currentPage > maxPages) {
      onPageChange(maxPages);
    }
  }, [currentPage, maxPages, onPageChange]);
  const handlePerPageOutOfBounds = useCallback(() => {
    if (itemsPerPage < 1 || isNaN(itemsPerPage) || itemsPerPage === undefined) {
      onItemsPerPageChange(itemsPerPageOptions[0]);
    }
  }, [itemsPerPage, onItemsPerPageChange, itemsPerPageOptions]);
  const calculateRange = useCallback(() => {
    let firstItemInRange = itemsPerPage * (currentPage - 1) + 1;
    let lastItemInRange = itemsPerPage * currentPage;
    firstItemInRange = Math.min(firstItemInRange, totalItems);
    lastItemInRange = Math.min(lastItemInRange, totalItems);
    if (lastItemInRange === 0 || isNaN(lastItemInRange) || isNaN(firstItemInRange)) {
      firstItemInRange = 0;
      lastItemInRange = 0;
    }
    setItemRange({
      start: firstItemInRange,
      end: lastItemInRange
    });
  }, [itemsPerPage, currentPage, totalItems]);
  useEffect(() => {
    handlePageOutOfBounds();
    handlePerPageOutOfBounds();
    calculateRange();
    setMaxPages(Math.max(1, Math.ceil(totalItems / itemsPerPage)));
  }, [calculateRange, currentPage, handlePageOutOfBounds, handlePerPageOutOfBounds, itemsPerPage, totalItems]);
  const handlePageIncrease = () => {
    onPageChange(currentPage + 1);
  };
  const handlePageDecrease = () => {
    onPageChange(currentPage - 1);
  };
  const handleRangeChange = item => {
    return onItemsPerPageChange(Number(item.hash));
  };
  return /*#__PURE__*/React.createElement(Flex, {
    "aria-label": label,
    flexDirection: "row",
    role: "navigation"
  }, /*#__PURE__*/React.createElement(FlexItem, null, /*#__PURE__*/React.createElement(Dropdown, {
    items: itemsPerPageOptions.map(range => ({
      content: `${range}`,
      hash: `${range}`,
      onItemClick: handleRangeChange
    })),
    positionFixed: true,
    toggle: /*#__PURE__*/React.createElement(StyledButton, {
      iconRight: /*#__PURE__*/React.createElement(ArrowDropDownIcon, {
        size: "xxLarge"
      }),
      type: "button",
      variant: "subtle"
    }, getRangeLabel(itemRange.start, itemRange.end, totalItems))
  })), /*#__PURE__*/React.createElement(FlexItem, null, /*#__PURE__*/React.createElement(StyledButton, {
    disabled: currentPage <= 1,
    iconOnly: /*#__PURE__*/React.createElement(ChevronLeftIcon, {
      title: localization.previousPage
    }),
    onClick: handlePageDecrease,
    type: "button",
    variant: "subtle"
  }), /*#__PURE__*/React.createElement(StyledButton, {
    disabled: currentPage >= maxPages,
    iconOnly: /*#__PURE__*/React.createElement(ChevronRightIcon, {
      title: localization.nextPage
    }),
    onClick: handlePageIncrease,
    type: "button",
    variant: "subtle"
  })));
});
Pagination.displayName = 'Pagination';