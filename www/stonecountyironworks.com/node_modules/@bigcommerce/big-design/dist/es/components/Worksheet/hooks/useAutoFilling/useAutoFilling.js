import { useCallback, useEffect, useMemo } from 'react';
import { useUpdateItems } from '../useUpdateItems';
import { useWorksheetStore } from '../useWorksheetStore';
export const useAutoFilling = cell => {
  const {
    store,
    useStore
  } = useWorksheetStore();
  const {
    updateItems
  } = useUpdateItems();
  const selectedCells = useStore(store, state => state.selectedCells);
  const disabledRows = useStore(store, state => state.disabledRows);
  const rows = useStore(store, useMemo(() => state => state.rows, []));
  const isBlockedFillOut = useStore(store, useMemo(() => state => state.isBlockedFillOut, []));
  const isSelectingActive = useStore(store, useMemo(() => state => state.isSelectingActive, []));
  const isAutoFillActive = useStore(store, useMemo(() => state => state.isAutoFillActive, []));
  const setSelectingActive = useStore(store, useMemo(() => state => state.setSelectingActive, []));
  const setAutoFillActive = useStore(store, useMemo(() => state => state.setAutoFillActive, []));
  const setBlockFillOut = useStore(store, useMemo(() => state => state.setBlockFillOut, []));
  const setSelectedCells = useStore(store, state => state.setSelectedCells);
  const onFillFullColumn = useCallback(() => {
    const cells = rows.reduce((accum, row, idx) =>
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    idx > cell.rowIndex && !disabledRows.includes(row.id) ? [...accum, {
      ...cell,
      rowIndex: idx,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      value: row[cell.hash]
    }] : accum, []);
    updateItems(cells, cells.map(() => cell.value));
  }, [cell, disabledRows, rows, updateItems]);
  const handleSelectedCells = useCallback(() => {
    const newSelectedCells = [];
    if (isAutoFillActive || isSelectingActive) {
      const firstSelectedCell = selectedCells[0];
      if (firstSelectedCell && firstSelectedCell.rowIndex <= cell.rowIndex) {
        const {
          columnIndex,
          hash,
          type
        } = firstSelectedCell;
        for (let i = firstSelectedCell.rowIndex; i <= cell.rowIndex; i++) {
          newSelectedCells.push({
            ...cell,
            columnIndex,
            rowIndex: i,
            hash,
            type,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            value: rows[i][firstSelectedCell.hash]
          });
        }
      }
      setSelectedCells(newSelectedCells);
    }
  }, [cell, isAutoFillActive, isSelectingActive, rows, selectedCells, setSelectedCells]);
  useEffect(() => {
    if (!isBlockedFillOut && !isAutoFillActive && selectedCells.length > 1) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      const selectedRowsIds = selectedCells.map(_ref => {
        let {
          rowIndex
        } = _ref;
        return rows[rowIndex].id;
      });
      const availableCells = selectedCells.filter(_ref2 => {
        let {
          rowIndex
        } = _ref2;
        return !disabledRows.includes(selectedRowsIds[rowIndex]);
      });
      updateItems(availableCells,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      availableCells.map(_ref3 => {
        let {
          hash
        } = _ref3;
        return rows[selectedCells[0].rowIndex][hash];
      }));
      setBlockFillOut(true);
    }
  }, [disabledRows, isAutoFillActive, isBlockedFillOut, isSelectingActive, rows, selectedCells, setSelectingActive, updateItems, setBlockFillOut]);
  return {
    isAutoFillActive,
    onFillFullColumn,
    setIsMouseDown: setAutoFillActive,
    setSelectingActive,
    setBlockFillOut,
    setSelectedCell: handleSelectedCells
  };
};