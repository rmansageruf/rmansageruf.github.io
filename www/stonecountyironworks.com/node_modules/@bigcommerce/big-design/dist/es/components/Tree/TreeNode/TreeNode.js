import _extends from "@babel/runtime/helpers/esm/extends";
import { CheckIcon, ChevronRightIcon, FolderIcon } from '@bigcommerce/big-design-icons';
import React, { useCallback, useContext, useEffect, useMemo, useRef } from 'react';
import { typedMemo } from '../../../utils';
import { StyledCheckbox } from '../../Checkbox/private';
import { StyledRadio } from '../../Radio/styled';
import { useSelectedChildrenCount } from '../hooks/useSelectedChildrenCount';
import { StyledUl } from '../styled';
import { TreeContext } from '../Tree';
import { StyledArrowWrapper, StyledFlex, StyledFlexItem, StyledGap, StyledLi, StyledSelectableWrapper, StyledText } from './styled';
const flexItemProps = {
  flexShrink: 0,
  marginLeft: 'xxSmall'
};
const InternalTreeNode = _ref => {
  let {
    children,
    icon,
    label,
    value,
    id
  } = _ref;
  const {
    disabledNodes,
    expandable,
    focusable,
    iconless,
    onKeyDown,
    onNodeClick,
    selectable,
    treeRef
  } = useContext(TreeContext);
  const nodeRef = useRef(null);
  const selectableRef = useRef(null);
  const isExpanded = expandable.expandedNodes.includes(id);
  const isSelected = selectable?.selectedNodes?.includes(id);
  const isDisabled = disabledNodes?.includes(id);
  const isSelectable = value !== undefined && selectable?.type !== undefined && !isDisabled;
  const selectedChildrenCount = useSelectedChildrenCount({
    selectedNodes: selectable?.selectedNodes,
    children
  });
  useEffect(() => {
    if (focusable.focusedNode === id && nodeRef.current !== document.activeElement && document.activeElement !== document.body && treeRef.current?.contains(document.activeElement)) {
      nodeRef.current?.focus();
    }
  }, [focusable, id, treeRef]);

  // Could be multiple elements in which are clicked.
  // Typing to generic Element type since all other elements extend from it.
  const handleNodeToggle = useCallback(async e => {
    // Prevents the collapse/expand when clicking on a radio or checkbox
    // Checks to see if every element inside the selectableRef gets clicked.
    if (e?.target instanceof Node && selectableRef.current?.contains(e.target) || children === undefined) {
      return;
    }
    if (typeof expandable.onToggle === 'function') {
      expandable.onToggle(id, isExpanded);
    }
    if (isExpanded) {
      if (typeof expandable.onCollapse === 'function') {
        expandable.onCollapse(id);
      }
    } else if (typeof expandable.onExpand === 'function') {
      expandable.onExpand(id);
    }
  }, [children, id, expandable, isExpanded]);
  const handleNodeSelected = useCallback(() => {
    if (!isSelectable) {
      return;
    }
    if (typeof selectable.onSelect === 'function') {
      selectable.onSelect(id, value);
    }
  }, [id, isSelectable, selectable, value]);
  const handleKeyEvent = useCallback(e => {
    if (e.altKey || e.currentTarget !== e.target) {
      return;
    }
    onKeyDown(e, {
      id,
      isExpanded,
      isSelectable,
      hasChildren: !!children?.length,
      value
    });
  }, [children, id, isExpanded, isSelectable, onKeyDown, value]);
  const handleNodeClick = useCallback(e => {
    // Prevents event bubbling
    e.stopPropagation();
    if (typeof focusable.onFocus === 'function') {
      focusable.onFocus(id);
    }
    if (typeof onNodeClick === 'function') {
      onNodeClick(e, id);
    }
  }, [focusable, id, onNodeClick]);
  const additionalProps = useMemo(() => selectable?.type ? {
    'aria-selected': isSelected
  } : {}, [selectable, isSelected]);
  const renderedArrow = useMemo(() => children ? /*#__PURE__*/React.createElement(StyledArrowWrapper, {
    expanded: isExpanded,
    flexShrink: 0
  }, /*#__PURE__*/React.createElement(ChevronRightIcon, {
    color: "secondary60",
    focusable: false,
    size: "xLarge"
  })) : /*#__PURE__*/React.createElement(StyledGap, null), [children, isExpanded]);
  const renderedChildren = useMemo(() => children && /*#__PURE__*/React.createElement(StyledUl, {
    role: "group",
    show: isExpanded
  }, children.map((child, index) => /*#__PURE__*/React.createElement(TreeNode, _extends({}, child, {
    key: index
  })))), [children, isExpanded]);
  const renderedIcon = useMemo(() => {
    if (iconless) {
      return null;
    }
    return icon ? /*#__PURE__*/React.createElement(StyledFlexItem, flexItemProps, icon) : /*#__PURE__*/React.createElement(StyledFlexItem, flexItemProps, /*#__PURE__*/React.createElement(FolderIcon, {
      color: isDisabled ? 'primary20' : 'primary30',
      size: "xLarge"
    }));
  }, [isDisabled, icon, iconless]);
  const renderedSelectable = useMemo(() => {
    if (value === undefined || !selectable?.type) {
      return null;
    }
    if (selectable.type === 'radio') {
      return /*#__PURE__*/React.createElement(StyledSelectableWrapper, flexItemProps, /*#__PURE__*/React.createElement(StyledRadio, {
        "aria-hidden": true,
        checked: isSelected,
        disabled: isDisabled,
        onClick: handleNodeSelected,
        ref: selectableRef
      }));
    }
    if (selectable.type === 'multi') {
      return /*#__PURE__*/React.createElement(StyledSelectableWrapper, flexItemProps, /*#__PURE__*/React.createElement(StyledCheckbox, {
        "aria-hidden": true,
        checked: isSelected,
        disabled: isDisabled,
        onClick: handleNodeSelected,
        ref: selectableRef
      }, isSelected ? /*#__PURE__*/React.createElement(CheckIcon, null) : null));
    }
  }, [isDisabled, handleNodeSelected, isSelected, selectable, value]);
  return useMemo(() => /*#__PURE__*/React.createElement(StyledLi, _extends({
    "aria-expanded": isExpanded,
    onClick: handleNodeClick,
    onKeyDown: handleKeyEvent,
    ref: nodeRef,
    role: "treeitem",
    tabIndex: focusable.focusedNode === id ? 0 : -1
  }, additionalProps), /*#__PURE__*/React.createElement(StyledFlex, {
    alignItems: "center",
    flexDirection: "row",
    onClick: handleNodeToggle,
    selected: isSelected
  }, renderedArrow, renderedSelectable, renderedIcon, /*#__PURE__*/React.createElement(StyledText, {
    as: "span",
    color: isDisabled ? 'secondary50' : 'secondary70',
    ellipsis: true,
    marginLeft: "xxSmall"
  }, label, selectedChildrenCount ? /*#__PURE__*/React.createElement(StyledText, {
    as: "span",
    color: "primary"
  }, ' ', "(", selectedChildrenCount, ")") : null)), renderedChildren), [additionalProps, handleKeyEvent, handleNodeClick, handleNodeToggle, id, isDisabled, isExpanded, isSelected, focusable, label, renderedArrow, renderedChildren, renderedSelectable, renderedIcon, selectedChildrenCount]);
};
export const TreeNode = typedMemo(InternalTreeNode);