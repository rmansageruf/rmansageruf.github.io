import { BaselineHelpIcon } from '@bigcommerce/big-design-icons';
import React, { createContext, createRef, useCallback, useEffect, useId, useMemo, useRef } from 'react';
import { typedMemo } from '../../utils';
import { Box } from '../Box';
import { Tooltip } from '../Tooltip';
import { UpdateItemsProvider } from './context';
import { createWorksheetStore, useKeyEvents, useWorksheetStore } from './hooks';
import { WorksheetModal } from './Modal/Modal';
import { Row } from './Row';
import { Status } from './RowStatus/styled';
import { Header, StyledBox, Table } from './styled';
import { editedRows, invalidRows } from './utils';
const InternalWorksheet = typedMemo(_ref => {
  let {
    columns,
    expandableRows,
    defaultExpandedRows,
    disabledRows,
    items,
    minWidth,
    onChange,
    onErrors
  } = _ref;
  const tableRef = /*#__PURE__*/createRef();
  const shouldBeTriggeredOnChange = useRef(false);
  const {
    store,
    useStore
  } = useWorksheetStore();
  const tooltipId = useId();
  const setRows = useStore(store, state => state.setRows);
  const setColumns = useStore(store, state => state.setColumns);
  const setExpandableRows = useStore(store, state => state.setExpandableRows);
  const setDisabledRows = useStore(store, state => state.setDisabledRows);
  const setTableRef = useStore(store, state => state.setTableRef);
  const resetInvalidCells = useStore(store, state => state.resetInvalidCells);
  const rows = useStore(store, useMemo(() => state => state.rows, []));
  const editedCells = useStore(store, useMemo(() => state => state.editedCells, []));
  const invalidCells = useStore(store, useMemo(() => state => state.invalidCells, []));
  const {
    handleKeyDown,
    handleKeyUp
  } = useKeyEvents();

  // Add a column for the toggle components
  const expandedColumns = useMemo(() => {
    return expandableRows ? [{
      hash: '',
      header: '',
      type: 'toggle',
      width: 32
    }, ...columns] : columns;
  }, [columns, expandableRows]);
  useEffect(() => {
    shouldBeTriggeredOnChange.current = editedCells.length > 0;
  }, [editedCells]);

  // Create a new reference since state mutates rows to prevent unecessary rerendering
  useEffect(() => {
    shouldBeTriggeredOnChange.current = false;
    resetInvalidCells();
    setRows([...items]);
  }, [items, resetInvalidCells, setRows]);
  useEffect(() => setColumns(expandedColumns), [expandedColumns, setColumns]);
  useEffect(() => setExpandableRows(expandableRows || {}, defaultExpandedRows || []), [expandableRows, defaultExpandedRows, setExpandableRows]);
  useEffect(() => setDisabledRows(disabledRows || []), [disabledRows, setDisabledRows]);
  useEffect(() => setTableRef(tableRef.current), [setTableRef, tableRef]);
  useEffect(() => {
    if (editedCells.length && shouldBeTriggeredOnChange.current) {
      onChange(editedRows(editedCells, rows));
    }
  }, [editedCells, onChange, rows]);
  useEffect(() => {
    if (typeof onErrors === 'function' && invalidCells.length) {
      onErrors(invalidRows(invalidCells, rows));
    }
  }, [invalidCells, onErrors, rows]);
  const getRenderedTooltip = useCallback(tooltip => {
    if (typeof tooltip === 'string' && tooltip.length > 0) {
      return /*#__PURE__*/React.createElement(Tooltip, {
        id: tooltipId,
        placement: "right",
        trigger: /*#__PURE__*/React.createElement(Box, {
          as: "span",
          marginLeft: "xxSmall"
        }, /*#__PURE__*/React.createElement(BaselineHelpIcon, {
          "aria-describedby": tooltipId,
          size: "medium",
          title: "Hover or focus for additional context."
        }))
      }, tooltip);
    }
    return null;
  }, [tooltipId]);
  const renderedHeaders = useMemo(() => /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement(Status, null), expandedColumns.map((column, index) => /*#__PURE__*/React.createElement(Header, {
    columnType: column.type,
    columnWidth: column.width || 'auto',
    key: index
  }, column.header, " ", getRenderedTooltip(column.tooltip))))), [expandedColumns, getRenderedTooltip]);
  const tableHasStaticWidth = useMemo(() => expandedColumns.every(column => column.width && typeof column.width === 'number'), [expandedColumns]);
  const renderedRows = useMemo(() => /*#__PURE__*/React.createElement("tbody", null, rows.map((_row, rowIndex) => /*#__PURE__*/React.createElement(Row, {
    columns: expandedColumns,
    key: rowIndex,
    rowIndex: rowIndex
  }))), [expandedColumns, rows]);
  const renderedModals = useMemo(() => expandedColumns.filter(column => column.type === 'modal').map((column, index) => /*#__PURE__*/React.createElement(WorksheetModal, {
    column: column,
    key: index
  })), [expandedColumns]);
  return /*#__PURE__*/React.createElement(UpdateItemsProvider, {
    items: rows
  }, /*#__PURE__*/React.createElement(StyledBox, null, /*#__PURE__*/React.createElement(Table, {
    hasExpandableRows: Boolean(expandableRows),
    hasStaticWidth: tableHasStaticWidth,
    minWidth: minWidth,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    ref: tableRef,
    tabIndex: 0
  }, renderedHeaders, renderedRows)), renderedModals);
});
export const WorksheetContext = /*#__PURE__*/createContext(null);
export const WorksheetLocalizationContext = /*#__PURE__*/createContext({
  toggleRowExpanded: 'toggle row expanded'
});
const defaultLocalization = {
  toggleRowExpanded: 'toggle row expanded'
};
export const Worksheet = typedMemo(_ref2 => {
  let {
    localization = defaultLocalization,
    ...props
  } = _ref2;
  const store = useMemo(() => createWorksheetStore(), []);
  return /*#__PURE__*/React.createElement(WorksheetContext.Provider, {
    value: store
  }, /*#__PURE__*/React.createElement(WorksheetLocalizationContext.Provider, {
    value: localization
  }, /*#__PURE__*/React.createElement(InternalWorksheet, props)));
});