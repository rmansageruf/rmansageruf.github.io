import { ErrorIcon } from '@bigcommerce/big-design-icons';
import React, { Children, createContext, Fragment, isValidElement, useMemo, useState } from 'react';
import { warning } from '../../../utils';
import { Checkbox } from '../../Checkbox';
import { Radio } from '../../Radio';
import { FormControlError } from '../Error';
import { useFormContext } from '../useFormContext';
import { StyledError, StyledGroup, StyledInlineGroup } from './styled';
export const FormGroupContext = /*#__PURE__*/createContext({});
export const FormGroup = props => {
  const {
    fullWidth
  } = useFormContext();
  const [inputErrors, setInputErrors] = useState({});
  const {
    children,
    errors: groupErrors
  } = props;
  const childrenCount = Children.count(children);
  const inline = !Children.toArray(children).every(child => {
    return /*#__PURE__*/isValidElement(child) && (child.type === Checkbox || child.type === Radio);
  });
  const contextValue = useMemo(() => ({
    errors: inputErrors,
    setErrors: setInputErrors
  }), [inputErrors]);
  const renderErrors = () => {
    // If Form.Group has errors prop, don't generate errors from children
    if (groupErrors) {
      return generateErrors(groupErrors, true);
    }
    return inputErrors && generateErrors(Object.values(inputErrors));
  };
  return /*#__PURE__*/React.createElement(FormGroupContext.Provider, {
    value: contextValue
  }, inline ? /*#__PURE__*/React.createElement(StyledInlineGroup, {
    childrenCount: childrenCount,
    fullWidth: fullWidth
  }, children, renderErrors()) : /*#__PURE__*/React.createElement(StyledGroup, null, children, renderErrors()));
};
const generateErrors = function (errors) {
  let fromGroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let key = arguments.length > 2 ? arguments[2] : undefined;
  if (typeof errors === 'string') {
    return /*#__PURE__*/React.createElement(Fragment, {
      key: key
    }, /*#__PURE__*/React.createElement(StyledError, {
      alignItems: "center"
    }, /*#__PURE__*/React.createElement(ErrorIcon, {
      color: "danger"
    }), /*#__PURE__*/React.createElement(FormControlError, null, errors)));
  }
  if ( /*#__PURE__*/isValidElement(errors) && errors.type === FormControlError) {
    return /*#__PURE__*/React.createElement(Fragment, {
      key: key
    }, /*#__PURE__*/React.createElement(StyledError, {
      alignItems: "center"
    }, /*#__PURE__*/React.createElement(ErrorIcon, {
      color: "danger"
    }), errors));
  }
  if (Array.isArray(errors)) {
    return errors.map((error, index) => error && generateErrors(error, fromGroup, index));
  }
  if (!errors) {
    return null;
  }
  if (fromGroup) {
    warning('errors must be either a string, FormControlError, or an array of strings or FormControlError components.');
  }
};