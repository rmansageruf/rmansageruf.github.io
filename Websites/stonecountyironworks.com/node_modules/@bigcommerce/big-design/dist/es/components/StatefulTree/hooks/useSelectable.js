import { useEffect, useState } from 'react';
import { depthFirstSearch } from '../../../utils';
const getDefaultSelectedValues = _ref => {
  let {
    nodes,
    selectedNodes,
    type
  } = _ref;
  if (type === 'radio') {
    const selectedNode = depthFirstSearch(nodes, _ref2 => {
      let {
        id,
        value
      } = _ref2;
      return selectedNodes.includes(id) && value !== undefined;
    });
    if (selectedNode && selectedNode.value !== undefined) {
      return [selectedNode.value];
    }
  }
  if (type === 'multi') {
    return depthFirstSearch(nodes, _ref3 => {
      let {
        id,
        value
      } = _ref3;
      return selectedNodes.includes(id) && value !== undefined;
    }, false)?.reduce((acc, node) => node.value !== undefined ? [...acc, node.value] : acc, []) ?? [];
  }
  return [];
};
export const useSelectable = _ref4 => {
  let {
    defaultSelected,
    disabledNodes,
    nodes,
    onSelectionChange,
    type
  } = _ref4;
  const [selectedNodes, setSelectedNodes] = useState(defaultSelected ?? []);
  const [selectedValues, setSelectedValues] = useState(() => type ? getDefaultSelectedValues({
    nodes,
    selectedNodes,
    type
  }) : []);
  useEffect(() => {
    if (defaultSelected) {
      setSelectedNodes(defaultSelected);
      setSelectedValues(getDefaultSelectedValues({
        nodes,
        selectedNodes: defaultSelected,
        type
      }));
    }
  }, [defaultSelected, nodes, type]);
  useEffect(() => {
    if (type === 'radio') {
      if (selectedNodes.length >= 1) {
        setSelectedNodes(prevSelected => prevSelected.slice(0, 1));
        setSelectedValues(prevValues => prevValues.slice(0, 1));
      } else if (nodes.length) {
        const firstSelectedNode = depthFirstSearch(nodes, node => node.value !== undefined, true);

        // Need to check for undefined value since TS can't determine from DFS check.
        if (firstSelectedNode && firstSelectedNode.value !== undefined) {
          setSelectedNodes([firstSelectedNode.id]);
          setSelectedValues([firstSelectedNode.value]);
        }
      }
    }
  }, [nodes, selectedNodes.length, setSelectedNodes, type]);
  useEffect(() => {
    if (typeof onSelectionChange === 'function') {
      onSelectionChange(selectedValues);
    }
  }, [onSelectionChange, selectedValues]);
  const onSelect = (nodeId, value) => {
    if (disabledNodes?.includes(nodeId)) {
      return;
    }
    if (type === 'multi') {
      if (selectedNodes.includes(nodeId)) {
        setSelectedNodes(prevNodes => prevNodes.filter(prevNodeId => prevNodeId !== nodeId));
        setSelectedValues(prevValues => prevValues.filter(prevValue => prevValue !== value));
      } else {
        setSelectedNodes([...selectedNodes, nodeId]);
        setSelectedValues([...selectedValues, value]);
      }
    }
    if (type === 'radio' && !selectedNodes.includes(nodeId)) {
      setSelectedNodes([nodeId]);
      setSelectedValues([value]);
    }
  };
  return {
    selectedNodes,
    onSelect
  };
};