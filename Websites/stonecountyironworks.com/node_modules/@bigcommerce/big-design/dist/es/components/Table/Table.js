import _extends from "@babel/runtime/helpers/esm/extends";
import React, { memo, useCallback, useEffect, useId, useRef, useState } from 'react';
import { DragDropContext, Draggable, Droppable } from 'react-beautiful-dnd';
import { useEventCallback } from '../../hooks';
import { typedMemo } from '../../utils';
import { Actions } from './Actions';
import { Body } from './Body';
import { Head } from './Head';
import { HeaderCell } from './HeaderCell';
import { DragIconHeaderCell, HeaderCheckboxCell } from './HeaderCell/HeaderCell';
import { Row } from './Row';
import { StyledTable, StyledTableFigure } from './styled';
const defaultLocalization = {
  ascendingOrder: 'Ascending order',
  descendingOrder: 'Descending order'
};
const InternalTable = props => {
  const {
    actions,
    className,
    columns,
    emptyComponent,
    headerless = false,
    id,
    itemName,
    items,
    keyField = 'id',
    localization = defaultLocalization,
    onRowDrop,
    pagination,
    selectable,
    sortable,
    stickyHeader,
    style,
    ...rest
  } = props;
  const actionsRef = useRef(null);
  const uniqueTableId = useId();
  const tableIdRef = useRef(id || uniqueTableId);
  const isSelectable = Boolean(selectable);
  const [selectedItems, setSelectedItems] = useState(new Set());
  const [headerCellWidths, setHeaderCellWidths] = useState([]);
  const headerCellIconRef = useRef(null);
  const eventCallback = useEventCallback(item => {
    if (!selectable || !item) {
      return;
    }
    const {
      onSelectionChange
    } = selectable;
    const nextIsSelected = !selectedItems.has(item);
    if (nextIsSelected) {
      onSelectionChange([...selectedItems, item]);
    } else {
      onSelectionChange([...selectedItems].filter(selectedItem => selectedItem !== item));
    }
  });
  const selectableConditionalDep = selectable ? selectable.selectedItems : null;
  useEffect(() => {
    if (selectable) {
      setSelectedItems(new Set(selectable.selectedItems));
    }
  }, [selectable, selectableConditionalDep]);
  const onItemSelect = selectable ? eventCallback : undefined;
  const onSortClick = useCallback(column => {
    if (!sortable || !column.isSortable) {
      return;
    }
    const {
      hash
    } = column;
    const sortDirection = sortable.direction === 'ASC' ? 'DESC' : 'ASC';
    if (typeof sortable.onSort === 'function') {
      sortable.onSort(hash, sortDirection, column);
    }
  }, [sortable]);
  const onDragEnd = useCallback(result => {
    const {
      destination,
      source
    } = result;
    if (!destination) {
      return;
    }
    if (destination.droppableId === source.droppableId && destination.index === source.index) {
      return;
    }
    if (typeof onRowDrop === 'function') {
      onRowDrop(source.index, destination.index);
    }
    setHeaderCellWidths([]);
  }, [onRowDrop]);
  const onBeforeDragStart = () => {
    const headerCellIconWidth = headerCellIconRef.current?.offsetWidth ?? 'auto';
    const headerCellsWidths = columns.map((_column, index) => {
      const headerCellElement = window.document.getElementById(`header-cell-${index}`);
      return headerCellElement?.getBoundingClientRect().width ?? 'auto';
    });
    const allHeaderWidths = [headerCellIconWidth, ...headerCellsWidths];
    setHeaderCellWidths(allHeaderWidths);
  };
  const shouldRenderActions = () => {
    return Boolean(actions) || Boolean(pagination) || Boolean(selectable) || Boolean(itemName);
  };
  const getItemKey = (item, index) => {
    if (item[keyField] !== undefined) {
      return item[keyField];
    }
    return index;
  };
  const renderHeaders = () => /*#__PURE__*/React.createElement(Head, {
    hidden: headerless
  }, /*#__PURE__*/React.createElement("tr", null, typeof onRowDrop === 'function' && /*#__PURE__*/React.createElement(DragIconHeaderCell, {
    actionsRef: actionsRef,
    headerCellIconRef: headerCellIconRef
  }), isSelectable && /*#__PURE__*/React.createElement(HeaderCheckboxCell, {
    actionsRef: actionsRef,
    stickyHeader: stickyHeader
  }), columns.map((column, index) => {
    const {
      display,
      hash,
      header,
      isSortable,
      hideHeader,
      width
    } = column;
    const isSorted = isSortable && sortable && hash === sortable.columnHash;
    const sortDirection = sortable && sortable.direction;
    const headerCellWidth = headerCellWidths[index + 1];
    const widthColumn = headerCellWidth ?? width;
    return /*#__PURE__*/React.createElement(HeaderCell, {
      actionsRef: actionsRef,
      column: {
        ...column,
        width: widthColumn
      },
      display: display,
      hide: hideHeader,
      id: `header-cell-${index}`,
      isSorted: isSorted,
      key: index,
      localization: localization,
      onSortClick: onSortClick,
      sortDirection: sortDirection,
      stickyHeader: stickyHeader
    }, header);
  })));
  const renderDroppableItems = () => /*#__PURE__*/React.createElement(Droppable, {
    droppableId: `${uniqueTableId}-bd-droppable`
  }, provided => /*#__PURE__*/React.createElement(Body, _extends({
    ref: provided.innerRef,
    withFirstRowBorder: headerless
  }, provided.droppableProps), items.map((item, index) => {
    const key = getItemKey(item, index);
    const isSelected = selectedItems.has(item);
    return /*#__PURE__*/React.createElement(Draggable, {
      draggableId: String(key),
      index: index,
      key: key
    }, (provided, snapshot) => /*#__PURE__*/React.createElement(Row, _extends({
      isDragging: snapshot.isDragging
    }, provided.dragHandleProps, provided.draggableProps, {
      columns: columns,
      headerCellWidths: headerCellWidths,
      isSelectable: isSelectable,
      isSelected: isSelected,
      item: item,
      onItemSelect: onItemSelect,
      ref: provided.innerRef,
      showDragIcon: true
    })));
  }), provided.placeholder));
  const renderItems = () => onRowDrop ? renderDroppableItems() : /*#__PURE__*/React.createElement(Body, {
    withFirstRowBorder: headerless
  }, items.map((item, index) => {
    const key = getItemKey(item, index);
    const isSelected = selectedItems.has(item);
    return /*#__PURE__*/React.createElement(Row, {
      columns: columns,
      headerCellWidths: headerCellWidths,
      isSelectable: isSelectable,
      isSelected: isSelected,
      item: item,
      key: key,
      onItemSelect: onItemSelect
    });
  }));
  const renderEmptyState = () => {
    if (items.length === 0 && emptyComponent) {
      return emptyComponent;
    }
    return null;
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderActions() && /*#__PURE__*/React.createElement(Actions, {
    customActions: actions,
    forwardedRef: actionsRef,
    itemName: itemName,
    items: items,
    onSelectionChange: selectable && selectable.onSelectionChange,
    pagination: pagination,
    selectedItems: selectedItems,
    stickyHeader: stickyHeader,
    tableId: tableIdRef.current
  }), /*#__PURE__*/React.createElement(StyledTable, _extends({}, rest, {
    id: tableIdRef.current
  }), onRowDrop ? /*#__PURE__*/React.createElement(DragDropContext, {
    onBeforeDragStart: onBeforeDragStart,
    onDragEnd: onDragEnd
  }, renderHeaders(), renderItems()) : /*#__PURE__*/React.createElement(React.Fragment, null, renderHeaders(), renderItems())), renderEmptyState());
};
export const Table = typedMemo(InternalTable);
export const TableFigure = /*#__PURE__*/memo(props => /*#__PURE__*/React.createElement(StyledTableFigure, props));