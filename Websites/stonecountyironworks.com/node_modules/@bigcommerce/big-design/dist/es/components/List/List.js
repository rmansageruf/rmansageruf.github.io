import _extends from "@babel/runtime/helpers/esm/extends";
import React, { forwardRef, Fragment, memo, useCallback, useMemo, useRef } from 'react';
import { useIsomorphicLayoutEffect, useWindowSize } from '../../hooks';
import { typedMemo } from '../../utils';
import { Box } from '../Box';
import { ListGroupHeader } from './GroupHeader';
import { ListGroupSeparator } from './GroupSeparator';
import { ListItem } from './Item';
import { StyledList } from './styled';
const StyleableList = typedMemo(_ref => {
  let {
    action,
    addItem,
    autoWidth,
    filteredItems,
    forwardedRef,
    getItemProps,
    getMenuProps,
    highlightedIndex,
    isDropdown = false,
    isOpen,
    items,
    maxHeight = 250,
    selectedItem,
    selectedItems,
    update,
    removeItem,
    ...props
  } = _ref;
  const itemKey = useRef(0);
  const {
    height,
    width
  } = useWindowSize();

  // Recalculate Popper for correct positioning
  useIsomorphicLayoutEffect(() => {
    async function scheduleUpdate() {
      // Only update when menu is open
      if (update && isOpen) {
        await update();
      }
    }
    scheduleUpdate();
  }, [isOpen, height, width, selectedItems?.length]);
  const renderAction = useCallback(action => {
    const key = itemKey.current;
    return /*#__PURE__*/React.createElement(Box, {
      borderTop: "box",
      marginTop: "xSmall",
      paddingTop: "xSmall"
    }, /*#__PURE__*/React.createElement(ListItem, {
      actionType: action.actionType,
      autoWidth: autoWidth,
      getItemProps: getItemProps,
      index: key,
      isAction: true,
      isHighlighted: highlightedIndex === key,
      isSelected: false,
      item: action,
      key: "action"
    }));
  }, [getItemProps, autoWidth, highlightedIndex]);
  const renderItems = useCallback(listItems => {
    return Array.isArray(listItems) && listItems.map(item => {
      // Skip rendering the option if it not found in the filtered list
      if (filteredItems && isOption(item) && !filteredItems.find(filteredItem => isOption(filteredItem) && filteredItem.value === item.value)) {
        return null;
      }
      const key = itemKey.current;
      itemKey.current += 1;
      const isChecked = isOption(item) && selectedItems && Boolean(selectedItems.find(selected => selected.value === item.value));
      const hasActionType = item => 'actionType' in item;
      return /*#__PURE__*/React.createElement(ListItem, {
        actionType: hasActionType(item) ? item.actionType : 'normal',
        addItem: addItem,
        autoWidth: autoWidth,
        getItemProps: getItemProps,
        index: key,
        isAction: isDropdown,
        isChecked: isChecked || false,
        isHighlighted: !item.disabled && highlightedIndex === key,
        isSelected: !isDropdown && isOption(item) && selectedItem?.value === item.value,
        item: item,
        key: `${key}-${item.content}`,
        removeItem: removeItem
      });
    });
  }, [addItem, autoWidth, filteredItems, getItemProps, highlightedIndex, isDropdown, removeItem, selectedItem, selectedItems]);
  const renderGroup = useCallback(group => {
    return /*#__PURE__*/React.createElement(React.Fragment, null, group.separated && /*#__PURE__*/React.createElement(ListGroupSeparator, null), Boolean(group.label) && /*#__PURE__*/React.createElement(ListGroupHeader, null, group.label), isItemGroup(group) && renderItems(group.items), isOptionGroup(group) && renderItems(group.options));
  }, [renderItems]);
  const renderChildren = useMemo(() => {
    // Reset the key every time we rerender children
    itemKey.current = 0;
    const groupFragment = items => items.map((group, index) => /*#__PURE__*/React.createElement(Fragment, {
      key: index
    }, renderGroup(group)));
    if (Array.isArray(items) && isGroups(items)) {
      return /*#__PURE__*/React.createElement(React.Fragment, null, groupFragment(items), action && renderAction(action));
    }
    if (Array.isArray(items) && isItems(items)) {
      return /*#__PURE__*/React.createElement(React.Fragment, null, renderItems(items), action && renderAction(action));
    }
  }, [action, items, renderAction, renderGroup, renderItems]);
  return /*#__PURE__*/React.createElement(StyledList, _extends({}, getMenuProps({
    ...props,
    onKeyDown: event => {
      if (event.key === 'Enter') {
        const element = event.currentTarget.children[highlightedIndex];
        const link = element.querySelector('a');

        // We want to click the link if it is selected
        if (link && !link.getAttribute('disabled')) {
          link.click();
        }
      }
    },
    ref: forwardedRef
  }), {
    maxHeight: maxHeight
  }), isOpen && renderChildren);
});
export const List = /*#__PURE__*/memo(
/*#__PURE__*/
// Using unknown because memo looses the generic type
forwardRef((props, ref) => /*#__PURE__*/React.createElement(StyleableList, _extends({}, props, {
  forwardedRef: ref
}))));
// Merging types into union
// Issue: https://github.com/microsoft/TypeScript/issues/33591

const isGroups = items => items.every(item => isItemGroup(item) || isOptionGroup(item));
const isItems = items => items.every(item => isItem(item) || isOption(item));
const isOption = item => 'value' in item;
const isItem = item => 'content' in item && !('items' in item);
const isItemGroup = item => 'items' in item && !('content' in item);
const isOptionGroup = item => 'options' in item && !('value' in item);