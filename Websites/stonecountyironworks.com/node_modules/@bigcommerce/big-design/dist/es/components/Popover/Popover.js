import _extends from "@babel/runtime/helpers/esm/extends";
import React, { useEffect, useId, useMemo, useRef, useState } from 'react';
import { usePopper } from 'react-popper';
import { excludeMarginProps } from '../../mixins';
import { Box } from '../Box';

// Margin can't be used with popper elements

export const Popover = _ref => {
  let {
    anchorElement,
    children,
    isOpen,
    role = 'dialog',
    ...props
  } = _ref;
  const uniquePopoverId = useId();
  const rest = excludeMarginProps(props);
  useEffect(() => {
    if (!anchorElement) {
      return;
    }
    anchorElement.setAttribute('aria-controls', uniquePopoverId);
    anchorElement.setAttribute('aria-expanded', String(isOpen));
    anchorElement.setAttribute('aria-haspopup', role);
  }, [anchorElement, isOpen, role, uniquePopoverId]);
  return isOpen ? /*#__PURE__*/React.createElement(InternalPopover, _extends({
    anchorElement: anchorElement
  }, rest, {
    id: uniquePopoverId
  }), children) : null;
};
// We use an Internal component that mounts/unmounts on isOpen
// This facilitates running cleanups on some effects.
const InternalPopover = _ref2 => {
  let {
    anchorElement,
    children,
    closeOnClickOutside = true,
    closeOnEscKey = true,
    id,
    label,
    matchAnchorElementWidth = false,
    skidding = 0,
    distance = 4,
    onClose = () => null,
    placement = 'auto',
    role,
    ...props
  } = _ref2;
  const [popperElement, setPopperElement] = useState(null);
  const previousFocus = useRef(typeof document !== 'undefined' ? document.activeElement : null);
  const popperModifiers = useMemo(() => [{
    name: 'offset',
    options: {
      offset: [skidding, distance]
    }
  }, {
    name: 'sameWidth',
    enabled: matchAnchorElementWidth,
    phase: 'beforeWrite',
    requires: ['computeStyles'],
    fn(_ref3) {
      let {
        state
      } = _ref3;
      state.styles.popper.width = `${state.rects.reference.width}px`;
    },
    effect(_ref4) {
      let {
        state
      } = _ref4;
      const element = state.elements.reference;
      if (element instanceof HTMLElement) {
        state.elements.popper.style.width = `${element.offsetWidth}px`;
      }
    }
  }], [skidding, distance, matchAnchorElementWidth]);
  const {
    styles,
    attributes
  } = usePopper(anchorElement, popperElement, {
    modifiers: popperModifiers,
    placement
  });
  useEffect(() => {
    const prevFocus = previousFocus.current;
    return () => {
      if (prevFocus instanceof HTMLElement) {
        prevFocus.focus();
      }
    };
  }, []);

  // Setup close on click outside
  useEffect(() => {
    if (typeof document === 'undefined' || !closeOnClickOutside) {
      return;
    }
    const clickHandler = event => {
      if (!(event.target instanceof Element)) {
        return;
      }
      if (popperElement?.contains(event.target)) {
        return;
      }
      if (anchorElement?.contains(event.target)) {
        return;
      }
      onClose();
    };
    document.addEventListener('click', clickHandler);
    return () => {
      document.removeEventListener('click', clickHandler);
    };
  }, [anchorElement, closeOnClickOutside, onClose, popperElement]);

  // Setup close on Esc key
  useEffect(() => {
    if (typeof document === 'undefined' || !closeOnEscKey) {
      return;
    }
    const keydownHandler = event => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('keydown', keydownHandler);
    return () => {
      document.removeEventListener('keydown', keydownHandler);
    };
  }, [closeOnEscKey, onClose]);
  return /*#__PURE__*/React.createElement(Box, _extends({
    "aria-label": label,
    backgroundColor: "white",
    padding: "medium",
    role: role,
    shadow: "floating",
    tabIndex: -1,
    zIndex: "popover"
  }, props, attributes.popper, {
    id: id,
    ref: setPopperElement,
    style: styles.popper
  }), children);
};