import React, { useCallback, useEffect, useId, useMemo } from 'react';
import { typedMemo } from '../../../utils';
import { Tooltip } from '../../Tooltip';
import { Small } from '../../Typography';
import { CheckboxEditor, ModalEditor, SelectEditor, TextEditor, ToggleEditor } from '../editors';
import { useAutoFilling, useEditableCell, useWorksheetStore } from '../hooks';
import { getCellIdx } from '../utils';
import { AutoFillHandler, CellNote, StyledCell } from './styled';
const InternalCell = _ref => {
  let {
    columnIndex,
    disabled = false,
    formatting,
    hash,
    options,
    rowIndex,
    type,
    rowId,
    validation,
    notation,
    value,
    nextRowValue,
    isChild,
    isLastChild
  } = _ref;
  const cell = useMemo(() => ({
    columnIndex,
    disabled,
    hash,
    rowIndex,
    type,
    value
  }), [columnIndex, disabled, hash, rowIndex, type, value]);
  const cellIdx = useMemo(() => getCellIdx(cell), [cell]);
  const {
    handleBlur,
    handleChange,
    handleDoubleClick,
    handleKeyDown,
    isEditing
  } = useEditableCell(cell);
  const {
    store,
    useStore
  } = useWorksheetStore();
  const {
    isAutoFillActive,
    onFillFullColumn,
    setIsMouseDown,
    setSelectingActive,
    setBlockFillOut,
    setSelectedCell: setHighlightedCell
  } = useAutoFilling(cell);
  const tooltipId = useId();
  const setSelectedRows = useStore(store, state => state.setSelectedRows);
  const setSelectedCells = useStore(store, state => state.setSelectedCells);
  const addInvalidCells = useStore(store, state => state.addInvalidCells);
  const removeInvalidCells = useStore(store, state => state.removeInvalidCells);
  const row = useStore(store, useMemo(() => state => state.rows[rowIndex], [rowIndex]));
  const editWithValue = useStore(store, useMemo(() => state => state.editWithValue, []));
  const isShiftPressed = useStore(store, useMemo(() => state => state.isShiftPressed, []));
  const isMetaKey = useStore(store, state => state.isMetaKey);
  const isControlKey = useStore(store, state => state.isControlKey);
  const {
    selectedCells,
    isLastSelected,
    isFirstSelected,
    isSelected
  } = useStore(store, useMemo(() => state => {
    const idx = Object.keys(state.selectedCellsMap).indexOf(cellIdx);
    return {
      selectedCells: state.selectedCells,
      isLastSelected: state.selectedCells.length - 1 === idx,
      isFirstSelected: idx === 0,
      isSelected: idx !== -1
    };
  }, [cellIdx]));
  const isEdited = useStore(store, useMemo(() => state => !!state.editedCellsMap[cellIdx], [cellIdx]));
  const invalidCell = useStore(store, useMemo(() => state => state.invalidCellsMap[cellIdx], [cellIdx]));
  const isValid = useMemo(() => typeof validation === 'function' ? validation(value) : true, [validation, value]);
  const isNextCellValid = useMemo(() => typeof validation === 'function' ? validation(nextRowValue) : true, [nextRowValue, validation]);
  useEffect(() => {
    // Remove from invalidCells if new value is valid
    if (isValid && invalidCell) {
      removeInvalidCells([cell]);
    }

    // Add to invalidCells but only if value is different
    if (!isValid && (!invalidCell || invalidCell.value !== cell.value)) {
      addInvalidCells([cell]);
    }
  }, [addInvalidCells, cell, isValid, invalidCell, removeInvalidCells]);
  const handleAutoFilldblClick = useCallback(event => {
    event.stopPropagation();
    onFillFullColumn();
  }, [onFillFullColumn]);
  const handleClick = useCallback(() => {
    if (isShiftPressed) {
      const lastSelected = selectedCells[selectedCells.length - 1];
      const fromIdx = lastSelected.rowIndex;
      const toIdx = cell.rowIndex;
      const rangeIdxs = Array.from({
        length: toIdx - fromIdx
      }, (_, index) => fromIdx + index + 1);
      const newCells = rangeIdxs.map(rowIndex => ({
        ...cell,
        columnIndex: lastSelected.columnIndex,
        rowIndex
      }));
      setSelectedCells([...selectedCells, ...newCells]);
    } else {
      setSelectedRows([rowIndex]);
      setSelectedCells([cell]);
    }
  }, [cell, isShiftPressed, rowIndex, selectedCells, setSelectedCells, setSelectedRows]);
  const renderedValue = useMemo(() => {
    if (typeof formatting === 'function' && value !== '' && !Number.isNaN(value)) {
      return formatting(value);
    }
    return `${value}`;
  }, [formatting, value]);
  const renderedCell = useMemo(() => {
    switch (type) {
      case 'select':
        return /*#__PURE__*/React.createElement(SelectEditor, {
          cell: cell,
          isEditing: isEditing,
          onBlur: handleBlur,
          onChange: handleChange,
          options: options
        });
      case 'checkbox':
        return /*#__PURE__*/React.createElement(CheckboxEditor, {
          cell: cell,
          onBlur: handleBlur,
          onChange: handleChange,
          toggle: isEditing
        });
      case 'modal':
        return /*#__PURE__*/React.createElement(ModalEditor, {
          cell: cell,
          formatting: formatting,
          isEditing: isEditing
        });
      case 'toggle':
        return /*#__PURE__*/React.createElement(ToggleEditor, {
          rowId: rowId,
          toggle: isEditing
        });
      default:
        return isEditing && !disabled ? /*#__PURE__*/React.createElement(TextEditor, {
          cell: cell,
          initialValue: editWithValue,
          isControlKey: isControlKey,
          isEdited: isEdited,
          isMetaKey: isMetaKey,
          onBlur: handleBlur,
          onKeyDown: handleKeyDown
        }) : /*#__PURE__*/React.createElement(Small, {
          color: disabled ? 'secondary50' : 'secondary70',
          ellipsis: true,
          title: renderedValue
        }, renderedValue);
    }
  }, [type, cell, handleBlur, handleChange, options, isEditing, formatting, rowId, disabled, editWithValue, isControlKey, isEdited, isMetaKey, handleKeyDown, renderedValue]);
  const renderedNote = useMemo(() => {
    if (!notation) {
      return null;
    }
    const note = notation(value, row);
    if (!note) {
      return null;
    }
    return /*#__PURE__*/React.createElement(Tooltip, {
      id: tooltipId,
      placement: "right",
      trigger: /*#__PURE__*/React.createElement(CellNote, {
        color: note.color,
        role: "note"
      })
    }, note.description);
  }, [notation, row, tooltipId, value]);
  const renderedAutoFillHandler = useMemo(() => {
    return isLastSelected ? /*#__PURE__*/React.createElement(AutoFillHandler, {
      "aria-label": "Autofill handler",
      isVisible: !isAutoFillActive,
      onDoubleClick: handleAutoFilldblClick,
      onMouseDown: event => {
        event.stopPropagation();
        setSelectingActive(false);
        setBlockFillOut(false);
        setIsMouseDown(true);
      }
    }) : null;
  }, [handleAutoFilldblClick, isAutoFillActive, isLastSelected, setBlockFillOut, setIsMouseDown, setSelectingActive]);
  return /*#__PURE__*/React.createElement(StyledCell, {
    isChild: isChild,
    isEdited: isEdited,
    isFirstSelected: isFirstSelected,
    isLastChild: isLastChild,
    isLastSelected: isLastSelected,
    isNextCellValid: isNextCellValid,
    isSelected: isSelected,
    isValid: isValid,
    onClick: handleClick,
    onDoubleClick: handleDoubleClick,
    onMouseDown: () => {
      handleClick();
      setSelectingActive(true);
      setBlockFillOut(true);
    },
    onMouseEnter: setHighlightedCell,
    onMouseUp: () => {
      setIsMouseDown(false);
      setSelectingActive(false);
    },
    type: type
  }, renderedCell, renderedAutoFillHandler, renderedNote);
};
export const Cell = typedMemo(InternalCell);