import _extends from "@babel/runtime/helpers/esm/extends";
import React, { memo, useCallback, useId, useRef, useState } from 'react';
import { DragDropContext, Draggable, Droppable } from 'react-beautiful-dnd';
import { typedMemo } from '../../utils';
import { Actions } from './Actions';
import { Body } from './Body';
import { Head } from './Head';
import { HeaderCell } from './HeaderCell';
import { DragIconHeaderCell, ExpandableHeaderCell, HeaderCheckboxCell } from './HeaderCell/HeaderCell';
import { getPagedIndex } from './helpers';
import { useExpandable, useSelectable } from './hooks';
import { RowContainer } from './RowContainer';
import { StyledTable, StyledTableFigure } from './styled';
const defaultLocalization = {
  ascendingOrder: 'Ascending order',
  descendingOrder: 'Descending order'
};
const InternalTableNext = props => {
  const {
    actions,
    className,
    columns,
    emptyComponent,
    expandable,
    headerless = false,
    id,
    itemName,
    items,
    keyField = 'id',
    localization = defaultLocalization,
    pagination,
    selectable,
    sortable,
    stickyHeader,
    style,
    onRowDrop,
    getRowId = (_item, parentRowIndex, childRowIndex) => {
      if (childRowIndex !== undefined) {
        return `${parentRowIndex}.${childRowIndex}`;
      }
      return `${parentRowIndex}`;
    },
    ...rest
  } = props;
  const actionsRef = useRef(null);
  const uniqueTableId = useId();
  const tableIdRef = useRef(id || uniqueTableId);
  const [headerCellWidths, setHeaderCellWidths] = useState([]);
  const headerCellIconRef = useRef(null);
  const {
    isSelectable,
    onItemSelect,
    selectedItems,
    isChildrenRowsSelectable,
    setSelectedParentRowsCrossPages,
    selectedParentRowsCrossPages
  } = useSelectable(selectable);
  const {
    expandedRows,
    getChildren,
    isExpandable,
    onExpandedRow,
    setExpandedRows
  } = useExpandable(expandable);
  const onSortClick = useCallback(column => {
    if (!sortable || !column.isSortable) {
      return;
    }
    const {
      hash
    } = column;
    const sortDirection = sortable.direction === 'ASC' ? 'DESC' : 'ASC';
    if (typeof sortable.onSort === 'function') {
      sortable.onSort(hash, sortDirection, column);
    }
  }, [sortable]);
  const onDragEnd = useCallback(result => {
    const {
      destination,
      source
    } = result;
    if (!destination) {
      return;
    }
    if (destination.droppableId === source.droppableId && destination.index === source.index) {
      return;
    }
    if (typeof onRowDrop === 'function') {
      onRowDrop(source.index, destination.index);
    }
    setHeaderCellWidths([]);
  }, [onRowDrop]);
  const onBeforeCapture = () => {
    if (isExpandable) {
      setExpandedRows({});
    }
  };
  const onBeforeDragStart = () => {
    const headerCellIconWidth = headerCellIconRef.current?.offsetWidth ?? 'auto';
    const headerCellsWidths = columns.map((_column, index) => {
      const headerCellElement = window.document.getElementById(`header-cell-${index}`);
      return headerCellElement?.getBoundingClientRect().width ?? 'auto';
    });
    const allHeaderWidths = [headerCellIconWidth, ...headerCellsWidths];
    setHeaderCellWidths(allHeaderWidths);
  };
  const shouldRenderActions = () => {
    return Boolean(actions) || Boolean(pagination) || Boolean(selectable) || Boolean(itemName);
  };
  const getItemKey = (item, index) => {
    if (item[keyField] !== undefined) {
      return item[keyField];
    }
    return index;
  };
  const renderHeaders = () => /*#__PURE__*/React.createElement(Head, {
    hidden: headerless
  }, /*#__PURE__*/React.createElement("tr", null, typeof onRowDrop === 'function' && /*#__PURE__*/React.createElement(DragIconHeaderCell, {
    actionsRef: actionsRef,
    headerCellIconRef: headerCellIconRef
  }), isSelectable && /*#__PURE__*/React.createElement(HeaderCheckboxCell, {
    actionsRef: actionsRef,
    stickyHeader: stickyHeader
  }), getChildren !== undefined && /*#__PURE__*/React.createElement(ExpandableHeaderCell, {
    actionsRef: actionsRef,
    headerCellIconRef: headerCellIconRef
  }), columns.map((column, index) => {
    const {
      display,
      hash,
      header,
      isSortable,
      hideHeader,
      width
    } = column;
    const isSorted = isSortable && sortable && hash === sortable.columnHash;
    const sortDirection = sortable && sortable.direction;
    const headerCellWidth = headerCellWidths[index + 1];
    const widthColumn = headerCellWidth ?? width;
    return /*#__PURE__*/React.createElement(HeaderCell, {
      actionsRef: actionsRef,
      column: {
        ...column,
        width: widthColumn
      },
      display: display,
      hide: hideHeader,
      id: `header-cell-${index}`,
      isSorted: isSorted,
      key: index,
      localization: localization,
      onSortClick: onSortClick,
      sortDirection: sortDirection,
      stickyHeader: stickyHeader
    }, header);
  })));
  const renderDroppableItems = () => /*#__PURE__*/React.createElement(Droppable, {
    droppableId: `${uniqueTableId}-bd-droppable`
  }, provided => /*#__PURE__*/React.createElement(Body, _extends({
    ref: provided.innerRef,
    withFirstRowBorder: headerless
  }, provided.droppableProps), items.map((item, index) => {
    const key = getItemKey(item, index);
    const pagedIndex = getPagedIndex(index, pagination);
    return /*#__PURE__*/React.createElement(Draggable, {
      draggableId: String(key),
      index: index,
      key: key
    }, (provided, snapshot) => /*#__PURE__*/React.createElement(RowContainer, _extends({
      isDragging: snapshot.isDragging
    }, provided.dragHandleProps, provided.draggableProps, {
      columns: columns,
      expandedRows: expandedRows,
      getChildren: getChildren,
      getItemKey: getItemKey,
      getLoadMoreAction: expandable?.getLoadMoreAction,
      getRowId: getRowId,
      headerCellWidths: headerCellWidths,
      isChildrenRowsSelectable: isChildrenRowsSelectable,
      isExpandable: isExpandable,
      isSelectable: isSelectable,
      item: item,
      key: key,
      onExpandedRow: onExpandedRow,
      onItemSelect: onItemSelect,
      parentRowIndex: pagedIndex,
      ref: provided.innerRef,
      selectedItems: selectedItems,
      showDragIcon: true
    })));
  }), provided.placeholder));
  const renderItems = () => onRowDrop ? renderDroppableItems() : /*#__PURE__*/React.createElement(Body, {
    withFirstRowBorder: headerless
  }, items.map((item, index) => {
    const key = getItemKey(item, index);
    const pagedIndex = getPagedIndex(index, pagination);
    return /*#__PURE__*/React.createElement(RowContainer, {
      columns: columns,
      expandedRows: expandedRows,
      getChildren: getChildren,
      getItemKey: getItemKey,
      getLoadMoreAction: expandable?.getLoadMoreAction,
      getRowId: getRowId,
      headerCellWidths: headerCellWidths,
      headerless: headerless,
      isChildrenRowsSelectable: isChildrenRowsSelectable,
      isExpandable: isExpandable,
      isSelectable: isSelectable,
      item: item,
      key: key,
      onExpandedRow: onExpandedRow,
      onItemSelect: onItemSelect,
      parentRowIndex: pagedIndex,
      selectedItems: selectedItems
    });
  }));
  const renderEmptyState = () => {
    if (items.length === 0 && emptyComponent) {
      return emptyComponent;
    }
    return null;
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderActions() && /*#__PURE__*/React.createElement(Actions, {
    customActions: actions,
    forwardedRef: actionsRef,
    getChildren: getChildren,
    getRowId: getRowId,
    isChildrenRowsSelectable: isChildrenRowsSelectable,
    itemName: itemName,
    items: items,
    onSelectionChange: selectable && selectable.onSelectionChange,
    pagination: pagination,
    selectedItems: selectedItems,
    selectedParentRowsCrossPages: selectedParentRowsCrossPages,
    setSelectedParentRowsCrossPages: setSelectedParentRowsCrossPages,
    stickyHeader: stickyHeader,
    tableId: tableIdRef.current
  }), /*#__PURE__*/React.createElement(StyledTable, _extends({}, rest, {
    id: tableIdRef.current
  }), onRowDrop ? /*#__PURE__*/React.createElement(DragDropContext, {
    onBeforeCapture: onBeforeCapture,
    onBeforeDragStart: onBeforeDragStart,
    onDragEnd: onDragEnd
  }, renderHeaders(), renderItems()) : /*#__PURE__*/React.createElement(React.Fragment, null, renderHeaders(), renderItems())), renderEmptyState());
};
export const TableNext = typedMemo(InternalTableNext);
export const TableFigureNext = /*#__PURE__*/memo(props => /*#__PURE__*/React.createElement(StyledTableFigure, props));