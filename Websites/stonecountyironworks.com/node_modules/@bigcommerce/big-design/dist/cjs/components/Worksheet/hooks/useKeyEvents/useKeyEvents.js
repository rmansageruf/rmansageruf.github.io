"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useKeyEvents = void 0;
var _react = require("react");
var _useNavigation = require("../useNavigation");
var _useWorksheetStore = require("../useWorksheetStore");
const useKeyEvents = () => {
  const {
    store,
    useStore
  } = (0, _useWorksheetStore.useWorksheetStore)();

  // Get the first cell of the selected values
  const selectedCell = useStore(store, (0, _react.useMemo)(() => state => state.selectedCells[0], []));
  const lastSelectedCell = useStore(store, (0, _react.useMemo)(() => state => state.selectedCells[state.selectedCells.length - 1], []));
  const selectedCells = useStore(store, (0, _react.useMemo)(() => state => state.selectedCells, []));
  const rows = useStore(store, (0, _react.useMemo)(() => state => state.rows, []));
  const isEditing = useStore(store, (0, _react.useMemo)(() => state => state.editingCell !== null, []));
  const isShiftPressed = useStore(store, (0, _react.useMemo)(() => state => state.isShiftPressed, []));
  const setShiftPressed = useStore(store, (0, _react.useMemo)(() => state => state.setShiftPressed, []));
  const setEditingCell = useStore(store, state => state.setEditingCell);
  const {
    navigate
  } = (0, _useNavigation.useNavigation)(selectedCell);
  const setSelectedCells = useStore(store, state => state.setSelectedCells);
  const editSelectedCell = (0, _react.useCallback)(function () {
    let {
      isMetaKey = false,
      isControlKey = false,
      editWithValue = ''
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (selectedCell) {
      return setEditingCell({
        cell: selectedCell,
        isMetaKey,
        isControlKey,
        editWithValue
      });
    }
  }, [selectedCell, setEditingCell]);
  const handleKeyUp = (0, _react.useCallback)(event => {
    const key = event.key;
    if (key === 'Shift') {
      setShiftPressed(false);
    }
  }, [setShiftPressed]);
  const handleKeyDown = (0, _react.useCallback)(event => {
    const key = event.key;
    if (isEditing) {
      switch (key) {
        case 'Enter':
          navigate({
            rowIndex: 1,
            columnIndex: 0
          });
          break;
        case 'Tab':
          navigate({
            rowIndex: 0,
            columnIndex: event.shiftKey ? -1 : 1
          });
          break;
      }
    } else {
      switch (key) {
        case 'Enter':
          if (selectedCell && !selectedCell.disabled) {
            editSelectedCell({});
            if (selectedCell.type === 'checkbox') {
              navigate({
                rowIndex: 1,
                columnIndex: 0
              });
            }
          }
          break;
        case ' ':
          if (selectedCell && !selectedCell.disabled) {
            editSelectedCell();
          }
          break;
        case 'ArrowUp':
          if (isShiftPressed && selectedCells.length > 1) {
            setSelectedCells(selectedCells.slice(0, -1));
            break;
          }
          navigate({
            rowIndex: -1,
            columnIndex: 0
          });
          break;
        case 'ArrowDown':
          if (isShiftPressed) {
            const nextRowIdx = lastSelectedCell.rowIndex + 1;
            const nextRow = rows[nextRowIdx];
            if (nextRowIdx <= rows.length - 1) {
              setSelectedCells([...selectedCells, {
                ...lastSelectedCell,
                rowIndex: lastSelectedCell.rowIndex + 1,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                value: nextRow[lastSelectedCell.hash]
              }]);
            }
          } else {
            navigate({
              rowIndex: 1,
              columnIndex: 0
            });
          }
          break;
        case 'ArrowRight':
          navigate({
            rowIndex: 0,
            columnIndex: 1
          });
          break;
        case 'Tab':
          navigate({
            rowIndex: 0,
            columnIndex: event.shiftKey ? -1 : 1
          });
          break;
        case 'ArrowLeft':
          navigate({
            rowIndex: 0,
            columnIndex: -1
          });
          break;
        case 'Meta':
          if (selectedCell) {
            editSelectedCell({
              isMetaKey: true
            });
          }
          break;
        case 'Control':
          if (selectedCell) {
            editSelectedCell({
              isControlKey: true
            });
          }
          break;
        case 'Shift':
          if (selectedCell) {
            setShiftPressed(true);
          }
          break;
        default:
          if (key !== 'Escape' && key.length === 1 && (selectedCell.type === 'text' || selectedCell.type === 'number')) {
            event.preventDefault();
            editSelectedCell({
              editWithValue: key
            });
          }
          break;
      }
      event.preventDefault();
    }
  }, [isEditing, navigate, selectedCell, isShiftPressed, selectedCells, editSelectedCell, setSelectedCells, lastSelectedCell, rows, setShiftPressed]);
  return (0, _react.useMemo)(() => ({
    handleKeyDown,
    handleKeyUp
  }), [handleKeyDown, handleKeyUp]);
};
exports.useKeyEvents = useKeyEvents;