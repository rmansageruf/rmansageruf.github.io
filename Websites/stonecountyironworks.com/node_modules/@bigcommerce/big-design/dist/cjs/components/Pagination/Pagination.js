"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pagination = void 0;
var _bigDesignIcons = require("@bigcommerce/big-design-icons");
var _react = _interopRequireWildcard(require("react"));
var _Dropdown = require("../Dropdown");
var _Flex = require("../Flex");
var _styled = require("./styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const defaultLocalization = {
  previousPage: 'Previous page',
  nextPage: 'Next page'
};
const defaultGetRangeLabel = (start, end, totalItems) => {
  if (start === end) {
    return `${start} of ${totalItems}`;
  }
  return `${start} - ${end} of ${totalItems}`;
};
const Pagination = /*#__PURE__*/(0, _react.memo)(_ref => {
  let {
    itemsPerPage,
    currentPage,
    totalItems,
    itemsPerPageOptions = [],
    onPageChange,
    onItemsPerPageChange,
    label = 'pagination',
    localization = defaultLocalization,
    getRangeLabel = defaultGetRangeLabel
  } = _ref;
  const [maxPages, setMaxPages] = (0, _react.useState)(Math.max(1, Math.ceil(totalItems / itemsPerPage)));
  const [itemRange, setItemRange] = (0, _react.useState)({
    start: 0,
    end: 0
  });
  const handlePageOutOfBounds = (0, _react.useCallback)(() => {
    if (currentPage < 1 || isNaN(currentPage) || currentPage === undefined) {
      onPageChange(1);
    } else if (currentPage > maxPages) {
      onPageChange(maxPages);
    }
  }, [currentPage, maxPages, onPageChange]);
  const handlePerPageOutOfBounds = (0, _react.useCallback)(() => {
    if (itemsPerPage < 1 || isNaN(itemsPerPage) || itemsPerPage === undefined) {
      onItemsPerPageChange(itemsPerPageOptions[0]);
    }
  }, [itemsPerPage, onItemsPerPageChange, itemsPerPageOptions]);
  const calculateRange = (0, _react.useCallback)(() => {
    let firstItemInRange = itemsPerPage * (currentPage - 1) + 1;
    let lastItemInRange = itemsPerPage * currentPage;
    firstItemInRange = Math.min(firstItemInRange, totalItems);
    lastItemInRange = Math.min(lastItemInRange, totalItems);
    if (lastItemInRange === 0 || isNaN(lastItemInRange) || isNaN(firstItemInRange)) {
      firstItemInRange = 0;
      lastItemInRange = 0;
    }
    setItemRange({
      start: firstItemInRange,
      end: lastItemInRange
    });
  }, [itemsPerPage, currentPage, totalItems]);
  (0, _react.useEffect)(() => {
    handlePageOutOfBounds();
    handlePerPageOutOfBounds();
    calculateRange();
    setMaxPages(Math.max(1, Math.ceil(totalItems / itemsPerPage)));
  }, [calculateRange, currentPage, handlePageOutOfBounds, handlePerPageOutOfBounds, itemsPerPage, totalItems]);
  const handlePageIncrease = () => {
    onPageChange(currentPage + 1);
  };
  const handlePageDecrease = () => {
    onPageChange(currentPage - 1);
  };
  const handleRangeChange = item => {
    return onItemsPerPageChange(Number(item.hash));
  };
  return /*#__PURE__*/_react.default.createElement(_Flex.Flex, {
    "aria-label": label,
    flexDirection: "row",
    role: "navigation"
  }, /*#__PURE__*/_react.default.createElement(_Flex.FlexItem, null, /*#__PURE__*/_react.default.createElement(_Dropdown.Dropdown, {
    items: itemsPerPageOptions.map(range => ({
      content: `${range}`,
      hash: `${range}`,
      onItemClick: handleRangeChange
    })),
    positionFixed: true,
    toggle: /*#__PURE__*/_react.default.createElement(_styled.StyledButton, {
      iconRight: /*#__PURE__*/_react.default.createElement(_bigDesignIcons.ArrowDropDownIcon, {
        size: "xxLarge"
      }),
      type: "button",
      variant: "subtle"
    }, getRangeLabel(itemRange.start, itemRange.end, totalItems))
  })), /*#__PURE__*/_react.default.createElement(_Flex.FlexItem, null, /*#__PURE__*/_react.default.createElement(_styled.StyledButton, {
    disabled: currentPage <= 1,
    iconOnly: /*#__PURE__*/_react.default.createElement(_bigDesignIcons.ChevronLeftIcon, {
      title: localization.previousPage
    }),
    onClick: handlePageDecrease,
    type: "button",
    variant: "subtle"
  }), /*#__PURE__*/_react.default.createElement(_styled.StyledButton, {
    disabled: currentPage >= maxPages,
    iconOnly: /*#__PURE__*/_react.default.createElement(_bigDesignIcons.ChevronRightIcon, {
      title: localization.nextPage
    }),
    onClick: handlePageIncrease,
    type: "button",
    variant: "subtle"
  })));
});
exports.Pagination = Pagination;
Pagination.displayName = 'Pagination';