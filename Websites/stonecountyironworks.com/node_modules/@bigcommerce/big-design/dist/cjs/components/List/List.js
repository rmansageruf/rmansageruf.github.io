"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.List = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _hooks = require("../../hooks");
var _utils = require("../../utils");
var _Box = require("../Box");
var _GroupHeader = require("./GroupHeader");
var _GroupSeparator = require("./GroupSeparator");
var _Item = require("./Item");
var _styled = require("./styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const StyleableList = (0, _utils.typedMemo)(_ref => {
  let {
    action,
    addItem,
    autoWidth,
    filteredItems,
    forwardedRef,
    getItemProps,
    getMenuProps,
    highlightedIndex,
    isDropdown = false,
    isOpen,
    items,
    maxHeight = 250,
    selectedItem,
    selectedItems,
    update,
    removeItem,
    ...props
  } = _ref;
  const itemKey = (0, _react.useRef)(0);
  const {
    height,
    width
  } = (0, _hooks.useWindowSize)();

  // Recalculate Popper for correct positioning
  (0, _hooks.useIsomorphicLayoutEffect)(() => {
    async function scheduleUpdate() {
      // Only update when menu is open
      if (update && isOpen) {
        await update();
      }
    }
    scheduleUpdate();
  }, [isOpen, height, width, selectedItems?.length]);
  const renderAction = (0, _react.useCallback)(action => {
    const key = itemKey.current;
    return /*#__PURE__*/_react.default.createElement(_Box.Box, {
      borderTop: "box",
      marginTop: "xSmall",
      paddingTop: "xSmall"
    }, /*#__PURE__*/_react.default.createElement(_Item.ListItem, {
      actionType: action.actionType,
      autoWidth: autoWidth,
      getItemProps: getItemProps,
      index: key,
      isAction: true,
      isHighlighted: highlightedIndex === key,
      isSelected: false,
      item: action,
      key: "action"
    }));
  }, [getItemProps, autoWidth, highlightedIndex]);
  const renderItems = (0, _react.useCallback)(listItems => {
    return Array.isArray(listItems) && listItems.map(item => {
      // Skip rendering the option if it not found in the filtered list
      if (filteredItems && isOption(item) && !filteredItems.find(filteredItem => isOption(filteredItem) && filteredItem.value === item.value)) {
        return null;
      }
      const key = itemKey.current;
      itemKey.current += 1;
      const isChecked = isOption(item) && selectedItems && Boolean(selectedItems.find(selected => selected.value === item.value));
      const hasActionType = item => 'actionType' in item;
      return /*#__PURE__*/_react.default.createElement(_Item.ListItem, {
        actionType: hasActionType(item) ? item.actionType : 'normal',
        addItem: addItem,
        autoWidth: autoWidth,
        getItemProps: getItemProps,
        index: key,
        isAction: isDropdown,
        isChecked: isChecked || false,
        isHighlighted: !item.disabled && highlightedIndex === key,
        isSelected: !isDropdown && isOption(item) && selectedItem?.value === item.value,
        item: item,
        key: `${key}-${item.content}`,
        removeItem: removeItem
      });
    });
  }, [addItem, autoWidth, filteredItems, getItemProps, highlightedIndex, isDropdown, removeItem, selectedItem, selectedItems]);
  const renderGroup = (0, _react.useCallback)(group => {
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, group.separated && /*#__PURE__*/_react.default.createElement(_GroupSeparator.ListGroupSeparator, null), Boolean(group.label) && /*#__PURE__*/_react.default.createElement(_GroupHeader.ListGroupHeader, null, group.label), isItemGroup(group) && renderItems(group.items), isOptionGroup(group) && renderItems(group.options));
  }, [renderItems]);
  const renderChildren = (0, _react.useMemo)(() => {
    // Reset the key every time we rerender children
    itemKey.current = 0;
    const groupFragment = items => items.map((group, index) => /*#__PURE__*/_react.default.createElement(_react.Fragment, {
      key: index
    }, renderGroup(group)));
    if (Array.isArray(items) && isGroups(items)) {
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, groupFragment(items), action && renderAction(action));
    }
    if (Array.isArray(items) && isItems(items)) {
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, renderItems(items), action && renderAction(action));
    }
  }, [action, items, renderAction, renderGroup, renderItems]);
  return /*#__PURE__*/_react.default.createElement(_styled.StyledList, (0, _extends2.default)({}, getMenuProps({
    ...props,
    onKeyDown: event => {
      if (event.key === 'Enter') {
        const element = event.currentTarget.children[highlightedIndex];
        const link = element.querySelector('a');

        // We want to click the link if it is selected
        if (link && !link.getAttribute('disabled')) {
          link.click();
        }
      }
    },
    ref: forwardedRef
  }), {
    maxHeight: maxHeight
  }), isOpen && renderChildren);
});
const List = /*#__PURE__*/(0, _react.memo)(
/*#__PURE__*/
// Using unknown because memo looses the generic type
(0, _react.forwardRef)((props, ref) => /*#__PURE__*/_react.default.createElement(StyleableList, (0, _extends2.default)({}, props, {
  forwardedRef: ref
}))));
exports.List = List;
// Merging types into union
// Issue: https://github.com/microsoft/TypeScript/issues/33591

const isGroups = items => items.every(item => isItemGroup(item) || isOptionGroup(item));
const isItems = items => items.every(item => isItem(item) || isOption(item));
const isOption = item => 'value' in item;
const isItem = item => 'content' in item && !('items' in item);
const isItemGroup = item => 'items' in item && !('content' in item);
const isOptionGroup = item => 'options' in item && !('value' in item);