"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormGroupContext = exports.FormGroup = void 0;
var _bigDesignIcons = require("@bigcommerce/big-design-icons");
var _react = _interopRequireWildcard(require("react"));
var _utils = require("../../../utils");
var _Checkbox = require("../../Checkbox");
var _Radio = require("../../Radio");
var _Error = require("../Error");
var _useFormContext = require("../useFormContext");
var _styled = require("./styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const FormGroupContext = /*#__PURE__*/(0, _react.createContext)({});
exports.FormGroupContext = FormGroupContext;
const FormGroup = props => {
  const {
    fullWidth
  } = (0, _useFormContext.useFormContext)();
  const [inputErrors, setInputErrors] = (0, _react.useState)({});
  const {
    children,
    errors: groupErrors
  } = props;
  const childrenCount = _react.Children.count(children);
  const inline = !_react.Children.toArray(children).every(child => {
    return /*#__PURE__*/(0, _react.isValidElement)(child) && (child.type === _Checkbox.Checkbox || child.type === _Radio.Radio);
  });
  const contextValue = (0, _react.useMemo)(() => ({
    errors: inputErrors,
    setErrors: setInputErrors
  }), [inputErrors]);
  const renderErrors = () => {
    // If Form.Group has errors prop, don't generate errors from children
    if (groupErrors) {
      return generateErrors(groupErrors, true);
    }
    return inputErrors && generateErrors(Object.values(inputErrors));
  };
  return /*#__PURE__*/_react.default.createElement(FormGroupContext.Provider, {
    value: contextValue
  }, inline ? /*#__PURE__*/_react.default.createElement(_styled.StyledInlineGroup, {
    childrenCount: childrenCount,
    fullWidth: fullWidth
  }, children, renderErrors()) : /*#__PURE__*/_react.default.createElement(_styled.StyledGroup, null, children, renderErrors()));
};
exports.FormGroup = FormGroup;
const generateErrors = function (errors) {
  let fromGroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let key = arguments.length > 2 ? arguments[2] : undefined;
  if (typeof errors === 'string') {
    return /*#__PURE__*/_react.default.createElement(_react.Fragment, {
      key: key
    }, /*#__PURE__*/_react.default.createElement(_styled.StyledError, {
      alignItems: "center"
    }, /*#__PURE__*/_react.default.createElement(_bigDesignIcons.ErrorIcon, {
      color: "danger"
    }), /*#__PURE__*/_react.default.createElement(_Error.FormControlError, null, errors)));
  }
  if ( /*#__PURE__*/(0, _react.isValidElement)(errors) && errors.type === _Error.FormControlError) {
    return /*#__PURE__*/_react.default.createElement(_react.Fragment, {
      key: key
    }, /*#__PURE__*/_react.default.createElement(_styled.StyledError, {
      alignItems: "center"
    }, /*#__PURE__*/_react.default.createElement(_bigDesignIcons.ErrorIcon, {
      color: "danger"
    }), errors));
  }
  if (Array.isArray(errors)) {
    return errors.map((error, index) => error && generateErrors(error, fromGroup, index));
  }
  if (!errors) {
    return null;
  }
  if (fromGroup) {
    (0, _utils.warning)('errors must be either a string, FormControlError, or an array of strings or FormControlError components.');
  }
};