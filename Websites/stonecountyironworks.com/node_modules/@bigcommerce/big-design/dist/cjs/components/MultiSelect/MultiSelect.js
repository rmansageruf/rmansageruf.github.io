"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiSelect = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _downshift = require("downshift");
var _react = _interopRequireWildcard(require("react"));
var _reactPopper = require("react-popper");
var _utils = require("../../utils");
var _Box = require("../Box");
var _Form = require("../Form");
var _Input = require("../Input");
var _List = require("../List");
var _styled = require("../Select/styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const MultiSelect = (0, _utils.typedMemo)(_ref => {
  let {
    action,
    autoComplete = 'off',
    autoWidth = false,
    className,
    disabled,
    filterable = true,
    id,
    inputRef,
    label,
    labelId,
    localization,
    maxHeight,
    onClose,
    onOpen,
    onOptionsChange,
    options,
    placeholder,
    placement = 'bottom-start',
    positionFixed = false,
    required,
    style,
    value,
    ...props
  } = _ref;
  const defaultRef = /*#__PURE__*/(0, _react.createRef)();
  const multiSelectUniqueId = (0, _react.useId)();
  const [inputValue, setInputValue] = (0, _react.useState)('');

  // aria-labelledby takes presedence over aria-label so we need to strip it out if there is no label
  // Downshift v7 automatically adds aria-labelledby to props even if there is no label defined
  // This is a workaround to remove the aria-labelledby if there is no label defined
  const ariaLabelledBy = (0, _react.useMemo)(() => {
    if (props['aria-label'] && !label) {
      return {
        'aria-labelledby': undefined
      };
    }
    return {};
  }, [label, props]);
  const flattenOptions = (0, _react.useCallback)(options => {
    const isGroups = options => options.every(option => 'options' in option && !('value' in option));
    return isGroups(options) ? options.map(group => group.options).reduce((acum, curr) => acum.concat(curr), []) : options;
  }, []);

  // We need to pass Downshift only options without groups for accessibility tracking
  const flattenedOptions = (0, _react.useMemo)(() => action ? [...flattenOptions(options), action] : flattenOptions(options), [action, flattenOptions, options]);

  // Find the selected options
  const selectedOptions = (0, _react.useMemo)(() => {
    return flattenedOptions.filter(option => 'value' in option && !!value && value.find(val => val === option.value) !== undefined) || [];
  }, [flattenedOptions, value]);

  // Initialize with flattened options
  const [filteredOptions, setFilteredOptions] = (0, _react.useState)(flattenedOptions);

  // Need to set items if options prop changes
  (0, _react.useEffect)(() => setFilteredOptions(flattenedOptions), [flattenedOptions]);
  (0, _react.useEffect)(() => {
    setInputValue('');
  }, [selectedOptions]);
  const getFirstMatchingOptionIndex = filteredOptions => {
    return filteredOptions.findIndex(option => !option.disabled);
  };
  const handleSetInputValue = _ref2 => {
    let {
      inputValue,
      isOpen
    } = _ref2;
    if (filterable && isOpen === true) {
      const newFilteredOptions = filterOptions(inputValue);
      const firstMatchingOptionIndex = getFirstMatchingOptionIndex(newFilteredOptions);
      setFilteredOptions(newFilteredOptions);

      // Auto highlight first matching option
      setHighlightedIndex(firstMatchingOptionIndex);
    }
    setInputValue(inputValue || '');
  };
  const filterOptions = function () {
    let inputVal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return flattenedOptions.filter(option => option === action || option.content.toLowerCase().startsWith(inputVal.trim().toLowerCase()));
  };
  const handleOnIsOpenChange = _ref3 => {
    let {
      isOpen
    } = _ref3;
    if (filterable && !isOpen) {
      // Reset the items if filtered
      setFilteredOptions(flattenedOptions);
    }
    if (isOpen && typeof onOpen === 'function') {
      onOpen();
    }
    if (!isOpen && typeof onClose === 'function') {
      onClose();
    }
  };
  const handleOnSelectedItemChange = changes => {
    if (action && changes.selectedItem === action) {
      action.onActionClick(inputValue);
    }
  };
  const handleStateReducer = (state, actionAndChanges) => {
    switch (actionAndChanges.type) {
      case _downshift.useCombobox.stateChangeTypes.InputBlur:
        return {
          ...actionAndChanges.changes,
          inputValue: ''
        };
      case _downshift.useCombobox.stateChangeTypes.InputFocus:
        return {
          ...actionAndChanges.changes,
          isOpen: false // keep the menu closed when input gets focused.
        };

      case _downshift.useCombobox.stateChangeTypes.InputKeyDownEnter:
      case _downshift.useCombobox.stateChangeTypes.ItemClick:
        {
          if (!actionAndChanges.changes.selectedItem) {
            return actionAndChanges.changes;
          }
          const isSelectAction = item => item === action;

          // Prevent action from changing the input value
          if (isSelectAction(actionAndChanges.changes.selectedItem)) {
            return {
              ...actionAndChanges.changes,
              inputValue: state.inputValue
            };
          }
          const isChecked = Boolean(selectedOptions.find(i => actionAndChanges.changes.selectedItem && 'value' in actionAndChanges.changes.selectedItem && i.value === actionAndChanges.changes.selectedItem.value));
          isChecked ? removeItem(actionAndChanges.changes.selectedItem) : addSelectedItem(actionAndChanges.changes.selectedItem);
          return {
            ...actionAndChanges.changes,
            highlightedIndex: state.highlightedIndex,
            inputValue: '',
            isOpen: true
          };
        }
      default:
        return actionAndChanges.changes;
    }
  };
  const removeItem = (0, _react.useCallback)(item => {
    if (!item) {
      return;
    }
    const newOptions = selectedOptions.filter(i => i.value !== item.value) || [];
    onOptionsChange(newOptions.map(option => option.value), newOptions);
    setFilteredOptions(flattenedOptions);
  }, [flattenedOptions, onOptionsChange, selectedOptions]);
  const addSelectedItem = (0, _react.useCallback)(item => {
    if (!item) {
      return;
    }
    const newOptions = [...selectedOptions, item];
    onOptionsChange(newOptions.map(option => option.value), newOptions);
    setFilteredOptions(flattenedOptions);
  }, [flattenedOptions, onOptionsChange, selectedOptions]);
  const {
    getInputProps,
    getItemProps,
    getLabelProps,
    getMenuProps,
    getToggleButtonProps,
    highlightedIndex,
    isOpen,
    openMenu,
    setHighlightedIndex
  } = (0, _downshift.useCombobox)({
    id: multiSelectUniqueId,
    initialHighlightedIndex: 0,
    inputId: id,
    inputValue,
    itemToString: option => option ? option.content : '',
    items: filteredOptions,
    labelId,
    onInputValueChange: handleSetInputValue,
    onIsOpenChange: handleOnIsOpenChange,
    onSelectedItemChange: handleOnSelectedItemChange,
    selectedItem: null,
    stateReducer: handleStateReducer
  });

  // Popper
  const referenceRef = (0, _react.useRef)(null);
  const popperRef = (0, _react.useRef)(null);
  const {
    styles,
    attributes,
    update
  } = (0, _reactPopper.usePopper)(referenceRef.current, popperRef.current, {
    modifiers: [{
      name: 'eventListeners',
      options: {
        scroll: isOpen,
        resize: isOpen
      }
    }, {
      name: 'offset',
      options: {
        offset: [0, 4]
      }
    }],
    strategy: positionFixed ? 'fixed' : 'absolute',
    placement
  });

  // Reset the value when Multiselect is closed
  (0, _react.useEffect)(() => {
    if (!isOpen) {
      setInputValue('');
    }
  }, [isOpen]);
  const setCallbackRef = (0, _react.useCallback)(ref => {
    if (typeof inputRef === 'function') {
      inputRef(ref);
    }
  }, [inputRef]);
  const getInputRef = (0, _react.useCallback)(() => {
    if (inputRef && typeof inputRef === 'object') {
      return inputRef;
    } else if (typeof inputRef === 'function') {
      return setCallbackRef;
    }
    return defaultRef;
  }, [defaultRef, inputRef, setCallbackRef]);
  const renderLabel = (0, _react.useMemo)(() => {
    if (!label) {
      return null;
    }
    if (typeof label === 'string') {
      return /*#__PURE__*/_react.default.createElement(_Form.FormControlLabel, (0, _extends2.default)({}, getLabelProps(), {
        localization: localization,
        renderOptional: !required
      }), label);
    }
    if ( /*#__PURE__*/(0, _react.isValidElement)(label) && label.type === _Form.FormControlLabel) {
      return /*#__PURE__*/(0, _react.cloneElement)(label, getLabelProps());
    }
    (0, _utils.warning)('label must be either a string or a FormControlLabel component.');
  }, [getLabelProps, label, localization, required]);
  const renderToggle = (0, _react.useMemo)(() => {
    return /*#__PURE__*/_react.default.createElement(_styled.DropdownButton, (0, _extends2.default)({}, getToggleButtonProps({
      disabled,
      type: 'button'
    }), {
      "aria-label": "toggle menu",
      variant: "subtle"
    }), /*#__PURE__*/_react.default.createElement(_styled.StyledDropdownIcon, null));
  }, [disabled, getToggleButtonProps]);
  const renderInput = (0, _react.useMemo)(() => {
    return /*#__PURE__*/_react.default.createElement(_styled.StyledInputContainer, {
      ref: referenceRef
    }, /*#__PURE__*/_react.default.createElement(_Input.Input, (0, _extends2.default)({}, getInputProps({
      ...props,
      ...ariaLabelledBy,
      autoComplete,
      disabled,
      onClick: () => {
        !isOpen && openMenu();
      },
      onFocus: event => {
        if (typeof props.onFocus === 'function') {
          props.onFocus(event);
        }
      },
      onKeyDown: event => {
        switch (event.key) {
          case 'Backspace':
            if (!inputValue) {
              removeItem(selectedOptions[selectedOptions.length - 1]);
            }
            break;
          case 'Enter':
            event.preventDefault();
            if (isOpen === false) {
              openMenu();
              // https://github.com/downshift-js/downshift/issues/734
              // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-unsafe-member-access
              event.nativeEvent.preventDownshiftDefault = true;
            }
            break;
          case 'Escape':
            // Reset select
            if (isOpen === false) {
              onOptionsChange([], []);
            }
            break;
        }
      },
      placeholder,
      ref: getInputRef()
    }), {
      chips: selectedOptions.map(option => ({
        label: option.content,
        onDelete: disabled ? undefined : () => removeItem(option)
      })),
      iconRight: renderToggle,
      readOnly: !filterable,
      required: required && selectedOptions.length === 0
    })));
  }, [autoComplete, ariaLabelledBy, disabled, filterable, getInputProps, getInputRef, inputValue, isOpen, onOptionsChange, openMenu, placeholder, props, removeItem, renderToggle, required, selectedOptions]);
  return /*#__PURE__*/_react.default.createElement("div", null, renderLabel, renderInput, /*#__PURE__*/_react.default.createElement(_Box.Box, (0, _extends2.default)({
    ref: popperRef,
    style: styles.popper
  }, attributes.poppper, {
    zIndex: "popover"
  }), /*#__PURE__*/_react.default.createElement(_List.List, {
    action: action,
    addItem: addSelectedItem,
    autoWidth: autoWidth,
    filteredItems: filteredOptions,
    getItemProps: getItemProps,
    getMenuProps: () => getMenuProps({
      ...ariaLabelledBy
    }),
    highlightedIndex: highlightedIndex,
    isOpen: isOpen,
    items: options,
    maxHeight: maxHeight,
    removeItem: removeItem,
    selectedItems: selectedOptions,
    update: update
  })));
});
exports.MultiSelect = MultiSelect;