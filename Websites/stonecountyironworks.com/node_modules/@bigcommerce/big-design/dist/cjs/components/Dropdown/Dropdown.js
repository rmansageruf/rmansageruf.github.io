"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dropdown = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _downshift = require("downshift");
var _react = _interopRequireWildcard(require("react"));
var _reactPopper = require("react-popper");
var _Box = require("../Box");
var _List = require("../List");
var _styled = require("./styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const Dropdown = /*#__PURE__*/(0, _react.memo)(_ref => {
  let {
    autoWidth = false,
    className,
    disabled = false,
    maxHeight,
    id,
    items,
    placement = 'bottom-start',
    positionFixed = false,
    toggle,
    style,
    ...props
  } = _ref;
  const dropdownUniqueId = (0, _react.useId)();
  const flattenItems = (0, _react.useCallback)(items => {
    const isGroups = items => items.every(items => 'items' in items && !('content' in items));
    return isGroups(items) ? items.map(group => group.items).reduce((acum, curr) => acum.concat(curr), []) : items;
  }, []);

  // We only need the items to pass down to Downshift, not groups
  const flattenedItems = (0, _react.useMemo)(() => flattenItems(items), [flattenItems, items]);
  const handleOnSelectedItemChange = (0, _react.useCallback)(_ref2 => {
    let {
      selectedItem
    } = _ref2;
    // Links don't trigger an onItemClick
    if (selectedItem && selectedItem.type !== 'link' && typeof selectedItem.onItemClick === 'function') {
      // Call onItemClick with selected item
      selectedItem.onItemClick(selectedItem);
    }
  }, []);
  const stateReducer = (state, actionAndChanges) => {
    const {
      changes,
      type
    } = actionAndChanges;
    switch (type) {
      case _downshift.useSelect.stateChangeTypes.ToggleButtonKeyDownArrowDown:
        if (state.highlightedIndex === flattenedItems.length - 1) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        }
        return changes;
      case _downshift.useSelect.stateChangeTypes.ToggleButtonKeyDownArrowUp:
        if (state.highlightedIndex === 0) {
          return {
            ...changes,
            highlightedIndex: flattenedItems.length - 1
          };
        }
        return changes;
      case _downshift.useSelect.stateChangeTypes.ToggleButtonBlur:
        return {
          ...changes,
          selectedItem: null
        };
      default:
        return changes;
    }
  };
  const {
    getItemProps,
    getMenuProps,
    getToggleButtonProps,
    highlightedIndex,
    isOpen
  } = (0, _downshift.useSelect)({
    defaultHighlightedIndex: 0,
    id: dropdownUniqueId,
    itemToString: item => item ? item.content : '',
    items: flattenedItems,
    menuId: id,
    onSelectedItemChange: handleOnSelectedItemChange,
    selectedItem: null,
    // We never set a selected item
    stateReducer,
    // @ts-expect-error toggle is of unknown type
    toggleButtonId: toggle.props.id
  });

  // Popper
  const referenceRef = (0, _react.useRef)(null);
  const popperRef = (0, _react.useRef)(null);
  const {
    attributes,
    styles,
    update
  } = (0, _reactPopper.usePopper)(referenceRef.current, popperRef.current, {
    modifiers: [{
      name: 'eventListeners',
      options: {
        scroll: isOpen,
        resize: isOpen
      }
    }, {
      name: 'offset',
      options: {
        offset: [0, 4]
      }
    }],
    placement,
    strategy: positionFixed ? 'fixed' : 'absolute'
  });
  const clonedToggle = /*#__PURE__*/(0, _react.isValidElement)(toggle) && /*#__PURE__*/(0, _react.cloneElement)(toggle, {
    ...getToggleButtonProps({
      'aria-haspopup': 'menu',
      // Downshift sets this to a label id that doesn't exist
      'aria-labelledby': undefined,
      disabled,
      ref: referenceRef,
      role: 'button'
    })
  });
  return /*#__PURE__*/_react.default.createElement(_styled.StyledBox, null, clonedToggle, /*#__PURE__*/_react.default.createElement(_Box.Box, (0, _extends2.default)({
    ref: popperRef,
    style: styles.popper
  }, attributes.poppper, {
    zIndex: "popover"
  }), /*#__PURE__*/_react.default.createElement(_List.List, (0, _extends2.default)({}, props, {
    autoWidth: autoWidth,
    getItemProps: getItemProps,
    getMenuProps: () => getMenuProps({
      role: 'menu'
    }),
    highlightedIndex: highlightedIndex,
    isDropdown: true,
    isOpen: isOpen,
    items: items,
    maxHeight: maxHeight,
    update: update
  }))));
});
exports.Dropdown = Dropdown;